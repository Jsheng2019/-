- [01.TCP三次握手和四次挥手](#01tcp三次握手和四次挥手)
		- [TCP基本认识](#tcp基本认识)
		- [UDP 和 TCP 的区别与应用场景](#udp-和-tcp-的区别与应用场景)
		- [三次握手](#三次握手)
		- [四次挥手](#四次挥手)
- [02.网络编程常用的API](#02网络编程常用的api)
- [03.IO多路复用](#03io多路复用)
# [01.TCP三次握手和四次挥手](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%A4%B4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B)

### TCP基本认识

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzguanBn?x-oss-process=image/format,png)

- **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
- **字节流**：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

***什么是TCP连接？***

用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括**Socket、序列号和窗口大小**称为连接。

所以我们可以知道，建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。

- **Socket**：由 IP 地址和端口号组成
- **序列号**：用来解决乱序问题等
- **窗口大小**：用来做流量控制

***如何唯一确定一个 TCP 连接呢？***

TCP 四元组可以唯一的确定一个连接，四元组包括如下：

- 源地址
- 源端口
- 目的地址
- 目的端口

![TCP 四元组](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEwLmpwZw?x-oss-process=image/format,png)

源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。

源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。

### UDP 和 TCP 的区别与应用场景

UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。

**TCP 和 UDP 区别：**

***1. 连接***

- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。

***2. 服务对象***

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信

***3. 可靠性***

- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。

***4. 拥塞控制、流量控制***

- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

***5. 首部开销***

- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 `20` 个字节，如果使用了「选项」字段则会变长的。
- UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

***6. 传输方式***

- TCP 是流式传输，没有边界，但保证顺序和可靠。
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

***7. 分片不同***

- TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

**TCP 和 UDP 应用场景：**

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- `FTP` 文件传输；
- HTTP / HTTPS；

由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 `DNS` 、`SNMP` 等；
- 视频、音频等多媒体通信；
- 广播通信；

### 三次握手

**握手过程**

TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而**建立连接是通过三次握手来进行的**。三次握手的过程如下图：

- 一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态

- 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1` ，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。

- 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。
- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 `ESTABLISHED` 状态。
- 服务器收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。

从上面的过程可以发现**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**。

一旦完成三次握手，双方都处于 `ESTABLISHED` 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。

**为什么是三次握手？**

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费

### 四次挥手

**挥手过程**

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务器收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

**为什么是四次挥手？**

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务器收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，因此是需要四次挥手。

# 02.网络编程常用的API

 **1. 创建套接字（socket函数）**

```C++
int socket(int domain, int type, int protocol);
- 第一个参数domain：指定协议族
- 第二个参数type:指定这个套接字的通信类型
- 第三个参数address_lenprotocol：指定使用的协议，设置为0表示使用默认协议。
返回值：成功返回套接字文件描述符，失败返回-1
作用：系统调用创建一个套接字并返回一个描述符，该描述符可以用来访问该套接字。
```

**2. 通用套接字数据结构（sockaddr）**

套接字编程需要指定套接字的地址作为参数，不同的协议族有不同的地址结构定义方式。例如以太网，其结构名称为sockaddr_in。

sockaddr为通用套接字数据结构，它可以在不同协议族之间进行强制转换。可以认为其他的地址结构都是由它进行细分出来的。

```c++
struct sockaddr{                    /* 套接字地址结构 */
    sa_family_t sun_family;         /* 协议族 */
    char            sa_data[14];    /* 协议族数据 */
}；            
typedef unsigned short sa_family_t；   /* 16位 */
```

**3. 以太网常用的地址结构（sockaddr_in）**

```C++
struct sockaddr_in{
   short int                 sin_family;    /* 协议族，以太网一般位AF_INET */
　 unsigned short int        sin_port;      /* 16位的端口号，网络字节序 */
　 struct in_addr           sin_addr;       /* IP地址32位 */
   char                    sin_zero[8];    /* 保留 */
};
```

由于结构struct sockaddr和结构struct sockaddr_in的大小是完全一致的，所以进行地址结构设置时，通常的方法是利用结构struct sockaddr_in进行设置，然后强制转换为结构struct sockaddr类型。因为这两个结构大小是完全一致的，所以进行这样的转换不会有副作用。

**4. 命名套接字（bind函数）**

```c++
#include <sys/socket.h>
#include <sys/types.h>
int bind(int socket, const struct sockaddr *address, size_t address_len);
- 第一个参数socket：由socket()函数创建得到得套接字描述符
- 第二个参数address：我们指定要绑定的域、IP地址和端口的sockaddr结构体
- 第三个参数address_len：sockaddr结构体的长度。通常使用sizeof(struct sockaddr)
返回值：0表示绑定成功，-1表示绑定失败。可以通过error查看错误值
作用：bind系统调用把参数address中的地址分配给与文件描述符socket关联。
```

**5. 创建套接字队列（listen函数）**

```C++
#include <sys/socket.h>
#include <sys/types.h>
int listen(int socket, int backlog);
第二个参数backlog：等待处理的进入连接的个数最多不能超过这个数字
返回值： 成功：0； 失败：-1；
作用：初始化服务器可连接队列，服务器处理客户端连接请求的时候是顺序处理的，同一时间仅能处理一个客户端连接。当多个客户端的连接请求同时到来的时候，服务器并不是同时处理，而是将不能处理的客户端连接请求放到等待队列中，这个队列的长度由listen()函数来定义。
```

**6. 接收连接（accept函数）**

```c++
#include <sys/socket.h>#include <sys/types.h>
int accept(int socket, struct sockaddr *address, size_t *address_len);　　
参数：当accept()函数返回的时候，会将客户端的信息存储在参数address中。
参数：address_len表示第二个参数所指内容的长度，可以使用sizeof(struct sockaddr_in)来获得。　　
需要注意的是：在accept中address_len参数是一个指针而不是结构，accept()函数将这个指针传给TCP/IP协议栈。　　
返回值：成功返回新的描述符用于和客户端进行通信。失败返回-1。
作用：只有当有客户程序试图连接到由socket参数指定的套接字上时才返回。这里的客户是指，在套接字队列中排在第一个的未处理连接。accpet函数将创建一个新的套接字来与该客户进行通信，并且返回新套接字的描述符。
```

**7. 请求连接（connect函数）**

```C++
#include <sys/socket.h>
int connect(int socket, const struct sockaddr *address, size_t address_len);参数：　　
- 第一个参数socket：建立套接字的时候返回的描述符　　
- 第二个参数address：一个指向数据结构sockaddr的指针，其中包括客户端需要连接的服务器的目的端口和ip地址，以及协议类型。　　
- 第三个参数address_len：表示第二个参数内容的大小，可以使用sizeof(struct sockaddr)获得，与bind函数不同，这个参数是一个整形的变量而不是指针。
返回值： 成功：0； 失败：-1
作用：参数socket指定的套接字将连接到参数address指定的服务器套接字，address指向的结构的长度由参数address_len指定。
```

**8. 写入数据函数（write，send，writev）**

```C++
int size 
char data[1024];
size = write(socket, data, 1024);    //将缓冲区data的数据全部写入套接字描述符socket中，返回值为成功写入的数据长度。　　注意：如果用tcp，socket是accept函数返回的套接字描述符。
```

```C++
#include <sys/types.h>
#include <sys/socket.h>

ssize_t send(int s, const void *buf, size_t len, int flags);
参数：和recv的参数基本一致。返回值：成功发送的字节数。发生错误的返回-1，可以查看errno获取错误码。
    
由于用户缓冲区buf中的数据在通过send()函数进行发送的时候，并不一定能够全部发送，所以要检查send()函数的返回值，按照与计划发送的字节长度len是否相等来判断如何进行下一步操作。
当send()函数的返回值小于len的时候，表明缓冲区中仍然有部分数据没有成功发送，这时需要重新发送剩余部分的数据。通常的剩余数据发送方法是对原来buf中的数据位置进行偏移，偏移的大小为已发送成功的字节数。
```

```C++
#include <sys/uio.h>
ssize_t writev(int fd, const srtuct iovec *vector, int count);
struct iovec{　　
	void *iov_base;　　　　/* 向量的缓冲区地址 */　　
	size_t iov_len;　　　　/* 向量缓冲区的大小，以字节为单位 */
};
作用：向套接字描述符s中写入在向量vector中保存的count块数据。
返回值：成功返回发送的字节数。错误返回-1，可以查看errno获取错误码。
```

**9. 读取数据函数（read，recv，readv）**

```C++
int size;
char data[1024];
size = read(socket, data, 1024);    
从套接字描述符socket中读取1024个字节，放入缓冲区data中，返回值是成功读取的数据大小
```

```c++
#include <sys/types.h>
#include <sys/socket.h>

ssize_t recv(int s, void *buf, size_t len, int flags);
参数：　　
	s：由socket函数得到得套接字描述符。　　
	buf：从套接字s中接收数据放在缓冲区buf中。　　
	len：buf的长度　　
	flag：用于设置接收数据的方式返回值：　　
错误返回-1，可以查看errno。成功返回接收的字节数。
recv()函数通常用于TCP类型，UDP使用recvfrom()函数接收数据，当然在数据报套接字绑定地址和端口后，也可以使用recv()函数接收数据。
```

```C++
#include <sys/uio.h>
ssize_t readv(int s, const struct iovec *vector, int count);
struct iovec{　　
	void *iov_base;　　　　　　/* 向量的缓冲区地址 */　　
	size_t iov_len;　　　　　　/* 向量缓冲区的大小，以字节为单位 */
};
作用：从套接字描述符s中读取count块数据放在缓冲区向量vector中。
返回值：成功接收到的字节数。错误返回-1，查看errno获取错误码。
```

**10. 关闭套接字函数（close，shutdown）**

```C++
#include <sys/socket.h>

int shutdown(int socket, int how);
参数：
	第一个参数是要切换通信的套接字描述符。　　
	第二个参数表示切断的方式。　　
		SHUT_RD:值为0，表示切断读。　　
		SHUT_WR:值为1，表示切断写。　　
		SHUT_RDWR:值为2，表示切换读写。
	返回值：成功返回0，失败返回-1
或者
close(socket);
close函数：关闭已经打开的socket连接，内核会释放相关的资源，关闭套接字之后就不能再使用这个套接字文件描述符进行读写操作。
shutdown函数：允许单方向切断通信或者切断双方的通信。
```

# [03.IO多路复用](https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84-socket-%E6%A8%A1%E5%9E%8B)

最基础的 TCP 的 Socket 编程，它是阻塞 I/O 模型，基本上只能一对一通信，那为了服务更多的客户端，我们需要改进网络 I/O 模型。

比较传统的方式是使用多进程/线程模型，每来一个客户端连接，就分配一个进程/线程，然后后续的读写都在对应的进程/线程，这种方式处理 100 个客户端没问题，但是当客户端增大到 10000 个时，10000 个进程/线程的调度、上下文切换以及它们占用的内存，都会成为瓶颈。

为了解决上面这个问题，就出现了 I/O 的多路复用，可以只在一个进程里处理多个文件的 I/O，Linux 下有三种提供 I/O 多路复用的 API，分别是： select、poll、epoll。

select 和 poll 并没有本质区别，它们内部都是使用「线性结构」来存储进程关注的 Socket 集合。

在使用的时候，首先需要把关注的 Socket 集合通过 select/poll 系统调用从用户态拷贝到内核态，然后由内核检测事件，当有网络事件产生时，内核需要遍历进程关注 Socket 集合，找到对应的 Socket，并设置其状态为可读/可写，然后把整个 Socket 集合从内核态拷贝到用户态，用户态还要继续遍历整个 Socket 集合找到可读/可写的 Socket，然后对其处理。

很明显发现，select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。

epoll 是解决 C10K 问题的利器，通过两个方面解决了 select/poll 的问题。

- epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select/poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。
- epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。

而且，epoll 支持边缘触发和水平触发的方式，而 select/poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。

# 04.DNS机制

DNS( Domain Name System)是“域名系统”的英文缩写，它所提供的服务是用来将主机名和域名转换为IP地址的工作。

**本地hosts  --  本地DNS缓存 -- 本地DNS服务器 -- 根DNS服务器(.) -- 顶级域名服务器(.com) -- 权威 DNS 服务器(server.com)** 

1、在浏览器中输入[www.qq.com](http://www.qq.com/)域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 
2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 
3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 
4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 
5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发

至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，

将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本

地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到[www.qq.com](http://www.qq.com/)主机。 
6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转

至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。

从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。

# 05.HTTP相关

## http基本概念

### 1. HTTP 是什么

HTTP 是超文本传输协议，也就是**H**yperText **T**ransfer **P**rotocol。

### 2. 超文本传输协议

HTTP的名字「超文本协议传输」，它可以拆成三个部分：

- 超文本
  - **超越了普通文本的文本**，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本
- 传输
  - HTTP 协议是一个双向协议
  - HTTP 是一个在计算机世界里专门用来在**两点之间传输数据**的约定和规范。
- 协议
  - HTTP 是一个用在计算机世界里的**协议**。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（**两个以上的参与者**），以及相关的各种控制和错误处理方式（**行为约定和规范**）。

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

### 3. HTTP 常见的状态码

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUfV6qkzg4yHtOibAfTv6hTicOx73F55WWl4nW2FWlXnDJ7Igd9kvrrRnA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

`2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

- 「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「**206 Partial Content**」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

`3xx` 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「**302 Moved Permanently**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
- 301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。

### 4. http 常见字段

***Host***

客户端发送请求时，用来指定服务器的域名。

有了 `Host` 字段，就可以将请求发往「同一台」服务器上的不同网站。

***Content-Length 字段***

服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。

```
Content-Length: 1000
```

如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。

***Connection 字段***

`Connection` 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。

HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。

```
Connection: keep-alive
```

一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。

***Content-Type 字段***

`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。

```
Content-Type: text/html; charset=utf-8
```

上面的类型表明，发送的是网页，而且编码是UTF-8。

客户端请求的时候，可以使用 `Accept` 字段声明自己可以接受哪些数据格式。

```
Accept: */*
```

上面代码中，客户端声明自己可以接受任何格式的数据。

***Content-Encoding 字段***

`Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

```
Content-Encoding: gzip
```

上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。

客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

```
Accept-Encoding: gzip, deflate
```

## GET与POST

### 1. GET 和 POST 的区别

`Get` 方法的含义是请求**从服务器获取资源**，这个资源可以是静态的文本、页面、图片视频等。

`POST` 方法则是相反操作，它向 `URI` 指定的资源提交数据，数据就放在报文的 body 里。

### 2. GET 和 POST 方法都是安全和幂等

安全和幂等的概念：

- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

那么很明显 **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。

**POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。

### 3. HTTP特性

HTTP 最凸出的优点是「**简单、灵活和易于扩展、应用广泛和跨平台**」

*1. 简单*

- HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。

*2. 灵活和易于扩展*

- HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。
- 同时 HTTP 由于是工作在应用层（ `OSI` 第七层），则它**下层可以随意变化**。
- HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。

*3. 应用广泛和跨平台*

HTTP 协议里有优缺点一体的**双刃剑**，分别是「**无状态、明文传输**」，同时还有一大缺点「**不安全**」。

*1. 无状态双刃剑*

- 无状态的**好处**，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。
- 无状态的**坏处**，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。
- 对于无状态的问题，解法方案有很多种，其中比较简单的方式用 **Cookie** 技术。`Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。相当于，**在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了**

*2. 明文传输双刃剑*

- 明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。
- HTTP 的所有信息都暴露在了光天化日下，相当于**信息裸奔**。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取

*3. 不安全*

- 通信使用明文（不加密），内容可能会被窃听。比如，**账号信息容易泄漏，那你号没了。**
- 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多，那你钱没了。**
- 无法证明报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告，视觉污染，眼没了。**

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。
