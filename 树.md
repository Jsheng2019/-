**目录**

- [104. 二叉树的最大深度](#104-二叉树的最大深度)
- [543. 二叉树的直径](#543-二叉树的直径)
- [96. 不同的二叉搜索树](#96-不同的二叉搜索树)
- [124. 二叉树中的最大路径和](#124-二叉树中的最大路径和)
- [236. 二叉树的最近公共祖先](#236-二叉树的最近公共祖先)
- [剑指 Offer 26. 树的子结构](#剑指-offer-26-树的子结构)
- [652. 寻找重复的子树](#652-寻找重复的子树)
- [95. 不同的二叉搜索树 II](#95-不同的二叉搜索树-ii)
- [94. 二叉树的中序遍历](#94-二叉树的中序遍历)
- [剑指 Offer 36. 二叉搜索树与双向链表](#剑指-offer-36-二叉搜索树与双向链表)
- [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
- [337. 打家劫舍 III](#337-打家劫舍-iii)
- [98. 验证二叉搜索树](#98-验证二叉搜索树)
- [101. 对称二叉树](#101-对称二叉树)
- [105. 从前序与中序遍历序列构造二叉树](#105-从前序与中序遍历序列构造二叉树)
- [226. 翻转二叉树](#226-翻转二叉树)
- [剑指 Offer 33. 二叉搜索树的后序遍历序列](#剑指-offer-33-二叉搜索树的后序遍历序列)
- [297. 二叉树的序列化与反序列化](#297-二叉树的序列化与反序列化)
- [103. 二叉树的锯齿形层序遍历](#103-二叉树的锯齿形层序遍历)
- [199. 二叉树的右视图](#199-二叉树的右视图)
- [257. 二叉树的所有路径](#257-二叉树的所有路径)
- [111. 二叉树的最小深度](#111-二叉树的最小深度)
- [112. 路径总和](#112-路径总和)
- [108. 将有序数组转换为二叉搜索树](#108-将有序数组转换为二叉搜索树)
- [450. 删除二叉搜索树中的节点](#450-删除二叉搜索树中的节点)

# [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

**题解一：递归**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int L = maxDepth(root->left);
        int R = maxDepth(root->right);
        return max(L, R) + 1;
    }
};
```

**题解二：BFS**

```C++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        queue<TreeNode*> que;
        que.push(root);
        int count = 0;
        while (!que.empty()) {
            count++;
            size_t n = que.size();
            while (n--) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return count;
    }
};
```

# [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：** 两结点之间的路径长度是以它们之间边的数目表示。

**题解一：递归**

在求深度的时候以每个节点为根的子树的最大直径`d = left+right`，对所有`d`取最大值

```C++
class Solution {
    int ans = 0;
    int depth(TreeNode* rt){
        if (rt == NULL) {
            return 0; // 访问到空节点了，返回0
        }
        int L = depth(rt->left); // 左儿子为根的子树的深度
        int R = depth(rt->right); // 右儿子为根的子树的深度
        ans = max(ans, L + R); // 计算d_node即L+R 并更新ans
        return max(L, R) + 1; // 返回该节点为根的子树的深度
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        depth(root);
        return ans;
    }
};
```

**题解二：面向对象思想**

对每个节点建立一个结构体，存储它的深度与最大半径

```C++
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        return process(root).maxDistance;
    }
    
    class info{
    public:
        info(int h, int m) {
            height = h;
            maxDistance = m;
        }
        int height, maxDistance;
    };
    
    info process(TreeNode* node) {
        if (node == NULL) {
            return info(0, 0);
        }
        info left = process(node->left);
        info right = process(node->right);
        int height = max(left.height, right.height) + 1;
        int d1 = max(left.maxDistance, right.maxDistance);
        int d2 = left.height + right.height;
        return info(height, max(d1, d2));
    }
    
};
```

# [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

**提示：**

- `1 <= n <= 19`

**题解一：动态规划（一）**

`dp[i]`代表节点数为`i`的二叉搜索数的种树，可以遍历其左子树与右子树的个数，利用前面确定的节点数对应的种树相乘计算当前结果

```C++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            int tmp = 0;
            for (int l = 0; l < i; l++) {
                int r = i - 1 - l;
                tmp += dp[l] * dp[r];
            }
            dp[i] = tmp;
        }
        return dp[n];
    }
};
```

**题解二：动态规划（二）**

```C++
 class Solution {
        /*
        dp[i] = i个不同的数组成的二叉搜索数的个数
        假设 i = 5
        当根节点等于 1 时 ，其余数字都比1大，只能在右边 dp[i] += dp[4]
        当根节点等于 2 时，左边有一个1比2小，右边有三个比2大的数字 dp[i] += dp[1] * dp[3]
        当根节点等于 3 时，左边有两个数比3小，右边有两个数比3大的数字 dp[i] += dp[2] * dp[2]
        ...
        知道根节点等于5，左边有4个数字比5小，只能放在5的左边,dp[i] += dp[4]
         */
        public int numTrees(int n) {
            int[] dp = new int[n + 1];
            dp[0] = 1;
            dp[1] = 1;
            for (int i = 2; i <= n; i++) {
                for (int j = 1; j <= i; j++) {
                    int leftNum = dp[j - 1];
                    int rightNum = dp[i - j];
                    dp[i] += leftNum * rightNum;
                }
            }
            return dp[n];
        }
    }
```

# [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

**提示：**

- 树中节点数目范围是 `[1, 3 * 104]`
- `-1000 <= Node.val <= 1000`

**题解一：后序遍历**

```C++
class Solution {
public:
    int res = INT_MIN;
    // 定义：计算从根节点 root 为起点的最大单边路径和
    int OneSideMax(TreeNode* root) {
        if (root == nullptr) return 0;
        int leftMaxSum = max(OneSideMax(root->left), 0);
        int rightMaxSum = max(OneSideMax(root->right), 0);
        int curMaxSum = leftMaxSum + rightMaxSum + root->val;
        // 后序遍历位置，顺便更新最大路径和
        res = max(res, curMaxSum);
        // 实现函数定义，左右子树的最大单边路径和加上根节点的值
        // 就是从根节点 root 为起点的最大单边路径和
        return max(leftMaxSum, rightMaxSum) + root->val;
    }
    int maxPathSum(TreeNode* root) {
        if (root == nullptr) return 0;
        // 计算单边路径和时顺便计算最大路径和
        OneSideMax(root);
        return res;
    }
};
```

# [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-109 <= Node.val <= 109`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

**题解一：递归**

若 *root* 是 *p, q* 的 **最近公共祖先** ，则只可能为以下情况之一：

1. *p* 和 *q* 在 *root* 的子树中，且分列 *root* 的 **异侧**（即分别在左、右子树中）；
1. *p* = *root* ，且 *q* 在 *root* 的左或右子树中；
1. *q* = *root* ，且 *p* 在 *root* 的左或右子树中；

考虑通过递归对二叉树进行先序遍历，当遇到节点 *p* 或 *q*  时返回。从底至顶回溯，当节点 *p, q*在节点 *root* 的异侧时，节点 *root*  即为最近公共祖先，则向上返回 *root* 。

```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if(left == nullptr && right == nullptr) return nullptr; // 1.
        if(left == nullptr) return right; // 3.
        if(right == nullptr) return left; // 4.
        return root; // 2. if(left != null and right != null)
    }
};
```

```C++
//情况 1. 可合并至 3. 和 4.
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if (root == nullptr) return right;
        if (right == nullptr) return left;
        return root; 
    }
};
```

# [剑指 Offer 26. 树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

```
     3
    / \
   4   5
  / \
 1   2
```

给定的树 B：

```
   4 
  /
 1
```

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

**示例 1：**

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

**示例 2：**

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

**限制：**

`0 <= 节点个数 <= 10000`

**题解一：递归**

```C++
class Solution {
public:
    // 这个函数用「遍历」的思维模式理解，遍历二叉树 A 的所有节点
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (A == nullptr || B == nullptr) {
            return false;
        }
        // 对于树 A 中的一个节点：
        // 1. 如果 A->val == B->val，则 A 可以作为根节点尝试去匹配树 B
        if (A->val == B->val && compareTree(A, B)) {
            return true;
        }
        // 2. 如果 A->val != B->val，就不要去匹配树 B 了
        return isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
    // 这个函数用「分解问题」的思路理解
    // 定义：输入两个根节点，返回从 rootA 开始是否可以完全匹配 rootB 树上的所有节点
    bool compareTree(TreeNode *rootA, TreeNode *rootB) {
        // base case
        if (rootB == nullptr) {
            return true;
        }
        if (rootA == nullptr) {
            return false;
        }
        if (rootA->val != rootB->val) {
            return false;
        }
        // rootA 的值和 rootB 的值匹配完成，去匹配子树的节点
        return compareTree(rootA->left, rootB->left) && compareTree(rootA->right, rootB->right);
    }

};
```

# [652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)

给定一棵二叉树 `root`，返回所有**重复的子树**。

对于同一类的重复子树，你只需要返回其中任意**一棵**的根结点即可。

如果两棵树具有**相同的结构**和**相同的结点值**，则它们是**重复**的。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/16/e1.jpg)

```
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/08/16/e2.jpg)

```
输入：root = [2,1,1]
输出：[[1]]
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/08/16/e33.jpg)

```
输入：root = [2,2,2,3,null,3,null]
输出：[[2,3],[3]]
```

**提示：**

- 树中的结点数在`[1,10^4]`范围内。
- `-200 <= Node.val <= 200`

**题解一：深度优先遍历**

```c++
class Solution {
public:
    unordered_map<string, int> map;
    vector<TreeNode*> res; 
    string dfs(TreeNode* root) {
        if (root == nullptr) return "#";
        string curPath = to_string(root->val) + "," + dfs(root->left) + "," + dfs(root->right);
        map[curPath]++;
        if (map[curPath] == 2) {
            res.push_back(root);
        }
        return curPath;
    }
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

**题解二：深度优先遍历（省空间版本）**

leetcode@[ffreturn](https://leetcode.cn/u/ffreturn/)

**主要思想是利用唯一的序号来代替一种子树结构**

子树是否相同的条件是

1. val相同
2. left和right的数值都是相同的

思路如下：

1. 采用深度优先的方式去遍历树
2. 去构建 包含 val,left,right 的子树的映射表， 同时这个子树需要一个编号去用于快速遍历（这里用递增的方式）
3. 构建子树编号的映射表，初始化为1，每次找到就+1，如果=2时候说明第一次发现有重复，则插入到结果里

```c++
class Solution {
private:
    // 结果的存储
    vector<TreeNode*> res;
    // 子树的编号，从1开始，用0表示是无效，后续递增来保证唯一
    int index = 1;
    // 子树 val,left,right的字符串 到唯一编号的映射
    unordered_map<string, int> str2index;
    // 唯一编号 到 数量的映射
    // unordered_map<int, int> index2cnt;
    // 这里假设是优先编号，如5000已满足测试需求来提速
    int index2cnt[5000];

    // 返回值为 当前节点对应的 唯一编号
    int dfs(TreeNode* curr)
    {
        if (curr != nullptr)
        {
            string currStr = to_string(curr->val) + "," + to_string(dfs(curr->left)) + "," + 	to_string(dfs(curr->right));
            if (str2index.find(currStr) == str2index.end())
            {
                str2index[currStr] = index;
                ++index;
            }
            int index = str2index[currStr];
            ++index2cnt[index];
            // 首次发现重复，增加结果里
            if (index2cnt[index] == 2)
            {
                res.push_back(curr);
            }
            return index;
        }
        else
        {
            return 0;
        }
    }

public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        dfs(root);
        memset(index2cnt, 0, sizeof(int) * 5000);
        return res;
    }
};

```

# [95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)

给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** 。可以按 **任意顺序** 返回答案。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

**提示：**

- `1 <= n <= 8`

**题解一：递归**

```C++
class Solution {
public:
    /* 构造闭区间 [lo, hi] 组成的 BST */
    vector<TreeNode*> build(int lo, int hi) {
        vector<TreeNode*> res;
        // base case
        if (lo > hi) {
            res.push_back(nullptr);
            return res;
        }
        // 1、穷举 root 节点的所有可能。
        for (int i = lo; i <= hi; i++) {
            // 2、递归构造出左右子树的所有合法 BST。
            vector<TreeNode*> leftTree = build(lo, i - 1);
            vector<TreeNode*> rightTree = build(i + 1, hi);           
            // 3、给 root 节点穷举所有左右子树的组合。
            for (auto l : leftTree) {
                for (auto r : rightTree) {
                    // i 作为根节点 root 的值
                    TreeNode* root = new TreeNode(i);
                    root->left = l;
                    root->right = r;
                    res.push_back(root);
                }
            }
        }
        return res;
    } 
    /* 主函数 */
    vector<TreeNode*> generateTrees(int n) {
        // 构造闭区间 [1, n] 组成的 BST
        return build(1, n);
    }
}; 
```

# [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

**题解一：递归**

```c++
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& res) {
        if (!root)  return;
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        inorder(root, res);
        return res;
    }
};
```

**题解二：迭代**

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        if (root == nullptr) return res;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
```

**题解三：统一迭代法（nullptr作访问标记）**

```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (root == nullptr) return ans;
        stack<TreeNode*> st; 
        st.push(root);
        while (!st.empty()) {
            TreeNode* cur = st.top();
            if (cur != nullptr) {
                st.pop();
                if (cur->right) st.push(cur->right);
                st.push(cur);
                st.push(nullptr);
                if (cur->left) st.push(cur->left);
            } else {
                st.pop();
                cur = st.top();
                ans.push_back(cur->val);
                st.pop();
            }
        }
        return ans;
    }
};
```

**题解四：统一迭代法（pair作访问标记）**

```C++
//以pair.second来标记什么时候访问元素
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<pair<TreeNode*, int> > stk;
        stk.push((make_pair(root, 0)));
        
        while(!stk.empty()) {
            auto [node, type] = stk.top();
            stk.pop();
            if(node == nullptr) continue;
            if(type == 0) {
                stk.push(make_pair(node->right, 0));
                stk.push(make_pair(node, 1));
                stk.push(make_pair(node->left, 0));
            }
            else result.emplace_back(node->val);
        }

        return result;

    }
};
```

# [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

为了让您更好地理解问题，以下面的二叉搜索树为例：

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png)

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

**题解一：宏观递归**

```C++
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if (!root) return root;
        Node* leftHead = treeToDoublyList(root->left);
        Node* rightHead = treeToDoublyList(root->right);
        Node* leftTail, *rightTail;
        if (leftHead) {
            leftTail = leftHead->left;
            leftTail->right = root;
            root->left = leftTail;
        } else {
            leftTail = leftHead = root;
        }
        if (rightHead) {
            rightTail = rightHead->left;
            root->right = rightHead;
            rightHead->left = root;
        } else {
            rightTail = rightHead = root;
        }
        leftHead->left = rightTail;
        rightTail->right = leftHead;
        return leftHead;       
    }
};
```

**题解二：中序遍历**

```C++
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if (!root) return NULL;
        dfs(root);
        head->left = pre;
        pre->right = head;
        return head;      
    }
private: 
    Node* pre, *head;
    void dfs(Node* node) {
        if (!node) return;
        dfs(node->left);
        if (pre != NULL) pre->right = node;
        else head = node;
        node->left = pre;
        pre = node;
        dfs(node->right);
    }
};
```

# [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

**题解一：迭代（广度优先遍历）**

```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if (root == nullptr) return ans;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int n = que.size();
            vector<int> cur_floor;
            while (n--) {
                TreeNode* cur = que.front();
                que.pop();
                cur_floor.push_back(cur->val);
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            ans.push_back(cur_floor);
        }
        return ans;
    }
};
```

**题解二：递归（深度优先遍历）**

```C++
class Solution {
public:
    vector<vector<int>> ans;
    void traversal(TreeNode* node, int layer) {
        if (!node) return;
        if (ans.size() == layer) ans.push_back(vector<int>());
        ans[layer].push_back(node->val);
        traversal(node->left, layer + 1);
        traversal(node->right, layer + 1); 
    }
    vector<vector<int>> levelOrder(TreeNode* root) {       
        traversal(root, 0);
        return ans;
    }
};
```

# [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)

```
输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
```

**提示：**

- 树的节点数在 `[1, 104]` 范围内
- `0 <= Node.val <= 104`

**思路**

leetcode@[房建斌学算法](https://leetcode.cn/u/reals/)

在解法一和解法二中，我们使用爷爷、两个孩子、4 个孙子来说明问题

1. 首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷
2. 二叉树只有左右两个孩子，一个爷爷最多 2 个儿子，4 个孙子

根据以上条件，我们可以得出单个节点的钱该怎么算

**4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构**

**题解一：暴力递归（代码超时）**

```c++
class Solution {
public:
    int rob(TreeNode* root) {
        if (root == nullptr) return 0;
        int money = root->val;
        if (root->left != nullptr) {
            money += rob(root->left->left) + rob(root->left->right);
        }
        if (root->right != nullptr) {
            money += rob(root->right->left) + rob(root->right->right);
        }
        return max(money, rob(root->left) + rob(root->right));
    }
};
```

**题解二：暴力递归 + 记忆化搜索**

针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点，也就是计算了**重复的子问题**。

针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。
由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，**TreeNode* 当做 key，能偷的钱当做 value**

```C++
class Solution {
public:
    unordered_map<TreeNode*, int> map;
    int rob(TreeNode* root) {
        if (root == nullptr) return 0;
        if (map.find(root) != map.end()) return map[root];
        int money = root->val;
        if (root->left != nullptr) {
            money += rob(root->left->left) + rob(root->left->right);
        }
        if (root->right != nullptr) {
            money += rob(root->right->left) + rob(root->right->right);
        }
        map[root] = max(money, rob(root->left) + rob(root->right));
        return map[root];
    }
};
```

**题解三：终极解法**

上面两种解法用到了孙子节点，计算爷爷节点能偷的钱还要同时去计算孙子节点投的钱，虽然有了记忆化，但是还是有性能损耗。

我们换一种办法来定义此问题

每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷

- 当前节点选择偷时，那么两个孩子节点就不能选择偷了
- 当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)

我们使用一个`pair`类型来表示 `pair.first` 代表不偷，`pair.second`代表偷 

**任何一个节点能偷到的最大钱的状态可以定义为**

1. 当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱
2. 当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数

表示为公式如下

```C++
ret.first = max(left.first, left.second) + max(right.first, right.second);
ret.second = left.first + right.first + root->val;
```

```C++
class Solution {
public:
    // first : not to choose current node
    // second : choose current node
    // 类似后续遍历 === 自底向上
    pair<int, int> helper(TreeNode* root) {
        if (root == nullptr) return {0, 0};
        pair<int, int> left = helper(root->left);
        pair<int, int> right = helper(root->right);
        pair<int, int> ret;
        ret.first = max(left.first, left.second) + max(right.first, right.second);
        ret.second = left.first + right.first + root->val;
        return ret;
    }
    int rob(TreeNode* root) {
        pair<int, int> res = helper(root);
        return max(res.first, res.second);
    }
};
```

# [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

 **示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

**提示：**

- 树中节点数目范围在`[1, 104]` 内
- `-231 <= Node.val <= 231 - 1`

**题解一：中序遍历（递归）**

中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。

```c++
class Solution {
public:
    long long pre = LONG_MIN;  
    bool isValidBST(TreeNode* root) {
        if (root == nullptr) 
            return true;
        if (!isValidBST(root->left)) 
            return false;
        if (root->val <= pre) 
            return false;
        pre = root->val;
        return isValidBST(root->right);
    }
};
```

**题解二：中序遍历（迭代）**

```C++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stack;
        long long pre = (long long)INT_MIN - 1;

        while (!stack.empty() || root != nullptr) {
            while (root != nullptr) {
                stack.push(root);
                root = root -> left;
            }
            root = stack.top();
            stack.pop();
            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root -> val <= pre) {
                return false;
            }
            pre = root -> val;
            root = root -> right;
        }
        return true;
    }
};
```

**题解三：范围判断**

如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。

这启示我们设计一个递归函数 `helper(root, lower, upper)` 来递归判断，函数表示考虑以 `root` 为根的子树，判断子树中所有节点的值是否都在 (l, r) 的范围内**（注意是开区间）**。如果 `root` 节点的值 `val` 不在 (l, r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。

在递归调用左子树时，我们需要把上界 `upper` 改为 `root.val`，即调用 `helper(root.left, lower, root.val)`，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 `lower` 改为 `root.val`，即调用 `helper(root.right, root.val, upper)`。

函数递归调用的入口为 `helper(root, -inf, +inf)`， `inf` 表示一个无穷大的值。

```C++
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```

# [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)



```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

**题解一：递归**

```C++
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        if (left == nullptr || right == nullptr) {
            return left == right;
        }
        // 两个根节点需要相同
        if (left->val != right->val) return false;
        // 左右子节点需要对称相同
        return compare(left->left, right->right) && compare(left->right, right->left);
        
    }
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) return true;
        // 检查两棵子树是否对称
        return compare(root->left, root->right);
    }
};
```

**题解二：迭代（队列）**

```C++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);
        que.push(root->right);
        while (!que.empty()) {
            TreeNode* left = que.front();
            que.pop();
            TreeNode* right = que.front();
            que.pop();
            if (!left && !right) continue;
            if (!left || !right || left->val != right->val) {
                return false;
            }
            que.push(left->left);
            que.push(right->right);
            que.push(left->right);
            que.push(right->left);
        }
        return true;
    }
};
```

**题解三：迭代（栈）**

```C++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        stack<TreeNode*> sta;
        sta.push(root->right);
        sta.push(root->left);
        while (!sta.empty()) {
            TreeNode* left = sta.top();
            sta.pop();
            TreeNode* right = sta.top();
            sta.pop();
            if (!left && !right) continue;
            if (!left || !right || left->val != right->val) {
                return false;
            }
            sta.push(right->left);
            sta.push(left->right);
            sta.push(right->right);
            sta.push(left->left);
        }
        return true;
    }
};
```

# [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2:**

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

**提示:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` 和 `inorder` 均 **无重复** 元素
- `inorder` 均出现在 `preorder`
- `preorder` **保证** 为二叉树的前序遍历序列
- `inorder` **保证** 为二叉树的中序遍历序列

**题解一：递归**

前序遍历数组中，从前往后依次取到根节点，对应的去中序数组中确定左子树和右子树的范围

```C++
class Solution {
public:
    int rootIndex = 0;
    TreeNode* buildTree(unordered_map<int, int> &map, int left, int right, vector<int>& preorder) {
        if (left > right) return nullptr;
        TreeNode* root = new TreeNode(preorder[rootIndex]);
        rootIndex++;
        int inorderIndex = map[root->val];
        root->left = buildTree(map, left, inorderIndex - 1, preorder);
        root->right = buildTree(map, inorderIndex + 1, right, preorder);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        unordered_map<int, int> map;
        for (int i = 0; i < inorder.size(); i++) {
            map[inorder[i]] = i;
        }
        return buildTree(map, 0, preorder.size() - 1, preorder);
    }
};
```

**题解二：递归**

**思路**

对于任意一颗树而言，前序遍历的形式总是

```
[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]
```

即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是

```
[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]
```

只要我们在中序遍历中**定位**到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有**左右括号**进行定位。

这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。

**细节**

在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1)*O*(1) 的时间对根节点进行定位了。

```C++
class Solution {
private:
    unordered_map<int, int> index;

public:
    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return nullptr;
        }
        
        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = index[preorder[preorder_root]];
        
        // 先把根节点建立出来
        TreeNode* root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root->left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root->right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        // 构造哈希映射，帮助我们快速定位根节点
        for (int i = 0; i < n; ++i) {
            index[inorder[i]] = i;
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```

# [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

**题解一：递归**

```C++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) return nullptr;
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

**题解二：迭代**

```C++
//DFS
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            swap(node->left, node->right);
            st.pop();
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return root;
    }
};
```

```c++
//BFS
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return NULL;
        queue<TreeNode*> que;
        que.push(root);
        while (!empty(que)) {
            size_t n = que.size();
            while (n--) {
                TreeNode* node = que.front();
                que.pop();
                swap(node->left, node->right);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```

# [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

```
     5
    / \
   2   6
  / \
 1   3
```

**示例 1：**

```
输入: [1,6,3,2,5]
输出: false
```

**示例 2：**

```
输入: [1,3,2,6,5]
输出: true
```

**提示：**

1. `数组长度 <= 1000`

**题解一：递归分治**

- 根据二叉搜索树的定义，可以通过递归，判断所有子树的 **正确性** （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。
- **终止条件：** 当 `i >= j`，说明此子树节点数量`<=1` ，无需判别正确性，因此直接返回 `true` ；

**递推工作：**

1. **划分左右子树：** 遍历后序遍历的`[i,j]`区间元素，寻找 **第一个大于根节点** 的节点，索引记为`m` 。此时，可划分出左子树区间`[i,m - 1]`、右子树区间 `[m,j - 1]`、根节点索引`j`。
2. **判断是否为二叉搜索树：**
   - **左子树区间** `[i,m - 1]`内的所有节点都应 `<postorder[j]`。而第 `1.划分左右子树` 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。
   - **右子树区间**`[m,j - 1]`内的所有节点都应`>postorder[j]`。实现方式为遍历，当遇到`<=postorder[j]`的节点则跳出；则可通过`p==j`判断是否为二叉搜索树。

**返回值：** 所有子树都需正确才可判定正确，因此使用 **与逻辑符**&&连接。

1. `p = j`判断 **此树** 是否正确
2. `recur(i, m-1)` **：** 判断 **此树的左子树** 是否正确。
3. `recur(m, j-1) ` **：** 判断 **此树的右子树** 是否正确。

```C++
class Solution {
public:
    bool fun(vector<int>& nums, int i, int j) {
        if (i >= j) return true;
        int p = i;
        while (nums[p] < nums[j]) p++;
        int index = p;
        while (nums[p] > nums[j]) p++;
        return p == j && fun(nums, i, index - 1) && fun(nums, index, j - 1);

    }
    bool verifyPostorder(vector<int>& nums) {
       return fun(nums, 0, nums.size() - 1);
    }
};
```

**题解二：单调栈**

```C++
class Solution {
public:
    bool verifyPostorder(vector<int>& nums) {
        stack<int> st;
        int parent = INT_MAX;
         //注意for循环是倒叙遍历的
        for (int i = nums.size() - 1; i >= 0; --i) {
            int cur = nums[i];
            //当如果前节点小于栈顶元素，说明栈顶元素和当前值构成了倒叙，
            //说明当前节点是前面某个节点的左子节点，我们要找到他的父节点
            while (!st.empty() && cur < st.top()) {
                parent = st.top();
                st.pop();
                //只要遇到了某一个左子节点，才会执行上面的代码，才会更
                //新parent的值，否则parent就是一个非常大的值，也就
                //是说如果一直没有遇到左子节点，那么右子节点可以非常大
            }
            if (cur > parent) return false;
            //入栈
            st.push(cur);
        }
        return true;
    }
};
```

**题解三：伪构造树**

```C++
class Solution {
public:
    int end;
    void build(vector<int>& nums, int min, int max) {

        if (end < 0) return;
        int curVal = nums[end];
        if (curVal > max || curVal < min) return;
        end--;
        build(nums, curVal, max);
        build(nums, min, curVal);      
    }
    bool verifyPostorder(vector<int>& nums) {
        if (nums.size() < 2) return true;
        end = nums.size() - 1;
        build(nums, INT_MIN, INT_MAX);
        return end < 0;
    }
};
```

# [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode.cn/faq/#binary-tree)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

**提示：**

- 树中结点数在范围 `[0, 104]` 内
- `-1000 <= Node.val <= 1000`

**题解一：层序遍历**

```C++
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) { 
        if (root == NULL) return "";
        string ans = "";     
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            TreeNode* node = que.front(); que.pop();
            if (node != NULL) {
                ans += to_string(node->val) + ',';
                que.push(node->left);
                que.push(node->right);               
            } else {
                ans += "#,";
            }
        }
        return ans;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data == "") return NULL;
        vector<TreeNode*> nodes;
        int index = 0;
        while (index < data.size()) {
            string s = "";
            //划分结点value
            while (data[index] != ',') {
                s += data[index];
                index++;
            }
            //构造结点
            if (s != "#") { 
                nodes.push_back(new TreeNode(stoi(s)));
            } else {
                nodes.push_back(NULL);
            }
            index++;
        }
        int pos = 1;
        for (int i = 0; i < nodes.size(); ++i) {
            if (nodes[i] == NULL) continue;
            nodes[i]->left = nodes[pos++];
            nodes[i]->right = nodes[pos++];
        }
        return nodes[0];
    }
};
```

**题解二：深度遍历**

```C++
class Codec {
public:
    void rserialize(TreeNode* root, string& str) {
        if (root == nullptr) {
            str += "None,";
        } else {
            str += to_string(root->val) + ",";
            rserialize(root->left, str);
            rserialize(root->right, str);
        }
    }

    string serialize(TreeNode* root) {
        string ret;
        rserialize(root, ret);
        return ret;
    }

    TreeNode* rdeserialize(list<string>& dataArray) {
        if (dataArray.front() == "None") {
            dataArray.erase(dataArray.begin());
            return nullptr;
        }

        TreeNode* root = new TreeNode(stoi(dataArray.front()));
        dataArray.erase(dataArray.begin());
        root->left = rdeserialize(dataArray);
        root->right = rdeserialize(dataArray);
        return root;
    }

    TreeNode* deserialize(string data) {
        list<string> dataArray;
        string str;
        for (auto& ch : data) {
            if (ch == ',') {
                dataArray.push_back(str);
                str.clear();
            } else {
                str.push_back(ch);
            }
        }
        if (!str.empty()) {
            dataArray.push_back(str);
            str.clear();
        }
        return rdeserialize(dataArray);
    }
};
```

# [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

**题解一：层序遍历**

```C++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if (!root) {
            return ans;
        }

        queue<TreeNode*> nodeQueue;
        nodeQueue.push(root);
        bool isOrderLeft = true;

        while (!nodeQueue.empty()) {
            deque<int> levelList;
            int size = nodeQueue.size();
            for (int i = 0; i < size; ++i) {
                auto node = nodeQueue.front();
                nodeQueue.pop();
                if (isOrderLeft) {
                    levelList.push_back(node->val);
                } else {
                    levelList.push_front(node->val);
                }
                if (node->left) {
                    nodeQueue.push(node->left);
                }
                if (node->right) {
                    nodeQueue.push(node->right);
                }
            }
            ans.emplace_back(vector<int>{levelList.begin(), levelList.end()});
            isOrderLeft = !isOrderLeft;
        }

        return ans;
    }
};
```

# [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

**示例 2:**

```
输入: [1,null,3]
输出: [1,3]
```

**示例 3:**

```
输入: []
输出: []
```

**提示:**

- 二叉树的节点个数的范围是 `[0,100]`
- `-100 <= Node.val <= 100` 

**题解一：DFS**

```C++
class Solution {
public:
    vector<int> ans;
    void dfs(int floor, TreeNode* node) {
        if (node == NULL) return;
        if (ans.size() == floor) {
            ans.push_back(node->val);
        } 
        if (node->right) dfs(floor + 1, node->right);
        if (node->left) dfs(floor + 1 ,node->left);       
    }
    vector<int> rightSideView(TreeNode* root) {
        dfs(0, root);
        return ans;
    }
};
```

**题解二：BFS**

```C++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        if(!root) return {};

        // bfs 层序遍历 将每层最后一个加入结果数组
        vector<int> ans;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty())
        {
            int counts = que.size();
            for(int i = 0; i < counts; ++i)
            {
                auto node = que.front();
                que.pop();

                if(node->left)  que.push(node->left);
                if(node->right) que.push(node->right);
                if(i == counts - 1) ans.push_back(node->val);
            }
        }

        return ans;
    }
};
```

# [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```

**提示：**

- 树中节点的数目在范围 `[1, 100]` 内
- `-100 <= Node.val <= 100`

**题解一：递归**

```C++
class Solution {
public:
    void traversal(TreeNode* cur, string path, vector<string> &ans) {
        path += to_string(cur->val);
        if (!cur->left && !cur->right) {
            ans.push_back(path);
            return;
        }
        if (cur->left) traversal(cur->left, path + "->", ans);
        if (cur->right) traversal(cur->right, path + "->", ans);
        
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> ans;
        string path;
        if (root == NULL) return ans;
        traversal(root, path, ans);
        return ans;
    }
};
```

**题解二：迭代**

```C++
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> ans;
        stack<TreeNode*> treeSt;
        stack<string> pathSt;
        if (root == nullptr) return ans;
        treeSt.push(root);
        pathSt.push(to_string(root->val));
        while (!treeSt.empty()) {
            TreeNode* cur = treeSt.top(); treeSt.pop();
            string path = pathSt.top(); pathSt.pop();
            if (!cur->left && !cur->right) {
                ans.push_back(path);
            }
            if (cur->right) {
                treeSt.push(cur->right);
                pathSt.push(path + "->" + to_string(cur->right->val));
            }
            if (cur->left) {
                treeSt.push(cur->left);
                pathSt.push(path + "->" + to_string(cur->left->val));
            }
        }
        return ans;
    }
};
```

# [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

**提示：**

- 树中节点数的范围在 `[0, 105]` 内
- `-1000 <= Node.val <= 1000`

**题解一：递归**

```C++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int L = minDepth(root->left);
        int R = minDepth(root->right);
        if (L == 0) return R + 1;
        if (R == 0) return L + 1;
        return min(L, R) + 1;
    }
};
```

**题解二：迭代**

```C++
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (root == nullptr) {
            return 0;
        }
        
        queue<pair<TreeNode *, int> > que;
        que.emplace(root, 1);
        while (!que.empty()) {
            TreeNode *node = que.front().first;
            int depth = que.front().second;
            que.pop();
            if (node->left == nullptr && node->right == nullptr) {
                return depth;
            }
            if (node->left != nullptr) {
                que.emplace(node->left, depth + 1);
            }
            if (node->right != nullptr) {
                que.emplace(node->right, depth + 1);
            }
        }

        return 0;
    }
};
```

# [112. 路径总和](https://leetcode.cn/problems/path-sum/)

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

**提示：**

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

**题解一：递归**

```C++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int target) {
        if (root == nullptr) return false;
        if (!root->left && !root->right) return target == root->val;
        return hasPathSum(root->left, target - root->val) || hasPathSum(root->right, target - root->val);   
    }
};
```

**题解二：迭代**

```C++
class solution {

public:
    bool haspathsum(treenode* root, int sum) {
        if (root == null) return false;
        // 此时栈里要放的是pair<节点指针，路径数值>
        stack<pair<treenode*, int>> st;
        st.push(pair<treenode*, int>(root, root->val));
        while (!st.empty()) {
            pair<treenode*, int> node = st.top();
            st.pop();
            // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if (!node.first->left && !node.first->right && sum == node.second) return true;

            // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->right) {
                st.push(pair<treenode*, int>(node.first->right, node.second + node.first->right->val));
            }

            // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->left) {
                st.push(pair<treenode*, int>(node.first->left, node.second + node.first->left->val));
            }
        }
        return false;
    }
};
```

# [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

![img](https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg)

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

**提示：**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 按 **严格递增** 顺序排列

**题解一：递归**

```C++
class Solution {
public:
    TreeNode* traversal(int begin, int end, vector<int> &nums) {
        if (end - begin < 0) return NULL;
        int center = (begin + end) / 2;
        TreeNode* root = new TreeNode(nums[center]);
        root->left = traversal(begin, center - 1, nums);
        root->right = traversal(center + 1, end, nums);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return traversal(0, nums.size() - 1, nums);
    }
};
```

**题解二：迭代**

```C++
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums)  {
        if (nums.size() == 1) return new TreeNode(nums[0]);
        queue<TreeNode*> node;
        queue<int> B;
        queue<int> E;
        TreeNode* root = new TreeNode();
        node.push(root);
        B.push(0);
        E.push(nums.size() - 1);
        while (!node.empty()) {
            TreeNode* cur = node.front(); node.pop();
            int b = B.front(); B.pop();
            int e = E.front(); E.pop();
            int c = (b + e) / 2;
            cur->val = nums[c];
            if (b <= c - 1) {
                cur->left = new TreeNode();
                node.push(cur->left);
                B.push(b);
                E.push(c - 1);
            }
            if (e >= c + 1) {
                cur->right = new TreeNode();
                node.push(cur->right);
                B.push(c + 1);
                E.push(e);
            }           
        }
        return root;
    }
};
```

# [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)

```
输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
```

![img](https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg)

**示例 2:**

```
输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
```

**示例 3:**

```
输入: root = [], key = 0
输出: []
```

**提示:**

- 节点数的范围 `[0, 104]`.
- `-105 <= Node.val <= 105`

- 节点值唯一
- `root` 是合法的二叉搜索树
- `-105 <= key <= 105`

 **进阶：** 要求算法时间复杂度为 O(h)，h 为树的高度。

**题解一：递归**

```C++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;
        if (root->val == key) {
            if (!root->right) {
                TreeNode* tmp = root->left;
                delete root;
                return tmp;
            } 
            TreeNode* tmp = root->right;
            TreeNode* cur = root->right;
            while (cur->left) cur = cur->left;
            if (root->left) cur->left = root->left;
            delete root;
            return tmp;
        }
        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};
```

**题解二：迭代**

```C++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == NULL) return root;
        if (root->val == key) {
            if (root->right) {
                TreeNode* tmp = root->left;
                root = root->right;
                TreeNode* cur = root;
                while (cur->left) cur = cur->left;
                cur->left = tmp;
            } else {
                root = root->left;
            }
            return root;
        }
        TreeNode* cur = root;
        TreeNode* parent = NULL;
        while (cur->val != key) {
            parent = cur;
            if (cur->val < key) cur = cur->right;
            else cur = cur->left;
            if (cur == NULL) return root;
        }
        if (parent->val > key) {
            if (cur->right) {
                parent->left = cur->right;
                TreeNode* node = cur->right;
                while (node->left)  node = node->left;
                node->left = cur->left;
            } else {
                parent->left = cur->left;
            }
        } else {
            if (cur->right) {
                parent->right = cur->right;
                TreeNode* node = cur->right;
                while (node->left) node = node->left;
                node->left = cur->left;
            } else {
                parent->right = cur->left;
            }
        }
        delete cur;
        return root;

    }
};
```

