# [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

**题解一：递归**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int L = maxDepth(root->left);
        int R = maxDepth(root->right);
        return max(L, R) + 1;
    }
};
```

**题解二：BFS**

```C++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        queue<TreeNode*> que;
        que.push(root);
        int count = 0;
        while (!que.empty()) {
            count++;
            size_t n = que.size();
            while (n--) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return count;
    }
};
```

# [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：**两结点之间的路径长度是以它们之间边的数目表示。

**题解一：递归**

在求深度的时候以每个节点为根的子树的最大直径`d = left+right`，对所有`d`取最大值

```C++
class Solution {
    int ans = 0;
    int depth(TreeNode* rt){
        if (rt == NULL) {
            return 0; // 访问到空节点了，返回0
        }
        int L = depth(rt->left); // 左儿子为根的子树的深度
        int R = depth(rt->right); // 右儿子为根的子树的深度
        ans = max(ans, L + R); // 计算d_node即L+R 并更新ans
        return max(L, R) + 1; // 返回该节点为根的子树的深度
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        depth(root);
        return ans;
    }
};
```

**题解二：面向对象思想**

对每个节点建立一个结构体，存储它的深度与最大半径

```C++
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        return process(root).maxDistance;
    }
    
    class info{
    public:
        info(int h, int m) {
            height = h;
            maxDistance = m;
        }
        int height, maxDistance;
    };
    
    info process(TreeNode* node) {
        if (node == NULL) {
            return info(0, 0);
        }
        info left = process(node->left);
        info right = process(node->right);
        int height = max(left.height, right.height) + 1;
        int d1 = max(left.maxDistance, right.maxDistance);
        int d2 = left.height + right.height;
        return info(height, max(d1, d2));
    }
    
};
```

# [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

**提示：**

- `1 <= n <= 19`

**题解一：动态规划（一）**

`dp[i]`代表节点数为`i`的二叉搜索数的种树，可以遍历其左子树与右子树的个数，利用前面确定的节点数对应的种树相乘计算当前结果

```C++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            int tmp = 0;
            for (int l = 0; l < i; l++) {
                int r = i - 1 - l;
                tmp += dp[l] * dp[r];
            }
            dp[i] = tmp;
        }
        return dp[n];
    }
};
```

**题解二：动态规划（二）**

```C++
 class Solution {
        /*
        dp[i] = i个不同的数组成的二叉搜索数的个数
        假设 i = 5
        当根节点等于 1 时 ，其余数字都比1大，只能在右边 dp[i] += dp[4]
        当根节点等于 2 时，左边有一个1比2小，右边有三个比2大的数字 dp[i] += dp[1] * dp[3]
        当根节点等于 3 时，左边有两个数比3小，右边有两个数比3大的数字 dp[i] += dp[2] * dp[2]
        ...
        知道根节点等于5，左边有4个数字比5小，只能放在5的左边,dp[i] += dp[4]
         */
        public int numTrees(int n) {
            int[] dp = new int[n + 1];
            dp[0] = 1;
            dp[1] = 1;
            for (int i = 2; i <= n; i++) {
                for (int j = 1; j <= i; j++) {
                    int leftNum = dp[j - 1];
                    int rightNum = dp[i - j];
                    dp[i] += leftNum * rightNum;
                }
            }
            return dp[n];
        }
    }
```

# [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

**提示：**

- 树中节点数目范围是 `[1, 3 * 104]`
- `-1000 <= Node.val <= 1000`

**题解一：后序遍历**

```C++
class Solution {
public:
    int res = INT_MIN;
    // 定义：计算从根节点 root 为起点的最大单边路径和
    int OneSideMax(TreeNode* root) {
        if (root == nullptr) return 0;
        int leftMaxSum = max(OneSideMax(root->left), 0);
        int rightMaxSum = max(OneSideMax(root->right), 0);
        int curMaxSum = leftMaxSum + rightMaxSum + root->val;
        // 后序遍历位置，顺便更新最大路径和
        res = max(res, curMaxSum);
        // 实现函数定义，左右子树的最大单边路径和加上根节点的值
        // 就是从根节点 root 为起点的最大单边路径和
        return max(leftMaxSum, rightMaxSum) + root->val;
    }
    int maxPathSum(TreeNode* root) {
        if (root == nullptr) return 0;
        // 计算单边路径和时顺便计算最大路径和
        OneSideMax(root);
        return res;
    }
};
```

# [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-109 <= Node.val <= 109`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

**题解一：递归**

若 *root* 是 *p, q* 的 **最近公共祖先** ，则只可能为以下情况之一：

1. *p* 和 *q* 在 *root* 的子树中，且分列 *root* 的 **异侧**（即分别在左、右子树中）；
1. *p* = *root* ，且 *q* 在 *root* 的左或右子树中；
1. *q* = *root* ，且 *p* 在 *root* 的左或右子树中；

考虑通过递归对二叉树进行先序遍历，当遇到节点 *p* 或 *q*  时返回。从底至顶回溯，当节点 *p, q*在节点 *root* 的异侧时，节点 *root*  即为最近公共祖先，则向上返回 *root* 。

```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if(left == nullptr && right == nullptr) return nullptr; // 1.
        if(left == nullptr) return right; // 3.
        if(right == nullptr) return left; // 4.
        return root; // 2. if(left != null and right != null)
    }
};
```

```C++
//情况 1. 可合并至 3. 和 4.
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if (root == nullptr) return right;
        if (right == nullptr) return left;
        return root; 
    }
};
```

# [剑指 Offer 26. 树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

```
     3
    / \
   4   5
  / \
 1   2
```

给定的树 B：

```
   4 
  /
 1
```

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

**示例 1：**

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

**示例 2：**

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

**限制：**

`0 <= 节点个数 <= 10000`

**题解一：递归**

```C++
class Solution {
public:
    // 这个函数用「遍历」的思维模式理解，遍历二叉树 A 的所有节点
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (A == nullptr || B == nullptr) {
            return false;
        }
        // 对于树 A 中的一个节点：
        // 1. 如果 A->val == B->val，则 A 可以作为根节点尝试去匹配树 B
        if (A->val == B->val && compareTree(A, B)) {
            return true;
        }
        // 2. 如果 A->val != B->val，就不要去匹配树 B 了
        return isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
    // 这个函数用「分解问题」的思路理解
    // 定义：输入两个根节点，返回从 rootA 开始是否可以完全匹配 rootB 树上的所有节点
    bool compareTree(TreeNode *rootA, TreeNode *rootB) {
        // base case
        if (rootB == nullptr) {
            return true;
        }
        if (rootA == nullptr) {
            return false;
        }
        if (rootA->val != rootB->val) {
            return false;
        }
        // rootA 的值和 rootB 的值匹配完成，去匹配子树的节点
        return compareTree(rootA->left, rootB->left) && compareTree(rootA->right, rootB->right);
    }

};
```

# [652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)

给定一棵二叉树 `root`，返回所有**重复的子树**。

对于同一类的重复子树，你只需要返回其中任意**一棵**的根结点即可。

如果两棵树具有**相同的结构**和**相同的结点值**，则它们是**重复**的。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/16/e1.jpg)

```
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/08/16/e2.jpg)

```
输入：root = [2,1,1]
输出：[[1]]
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/08/16/e33.jpg)

```
输入：root = [2,2,2,3,null,3,null]
输出：[[2,3],[3]]
```

**提示：**

- 树中的结点数在`[1,10^4]`范围内。
- `-200 <= Node.val <= 200`
