**目录**

- [104. 二叉树的最大深度](#104-二叉树的最大深度)
- [543. 二叉树的直径](#543-二叉树的直径)
- [96. 不同的二叉搜索树](#96-不同的二叉搜索树)
- [124. 二叉树中的最大路径和](#124-二叉树中的最大路径和)
- [236. 二叉树的最近公共祖先](#236-二叉树的最近公共祖先)
- [剑指 Offer 26. 树的子结构](#剑指-offer-26-树的子结构)
- [652. 寻找重复的子树](#652-寻找重复的子树)
- [95. 不同的二叉搜索树 II](#95-不同的二叉搜索树-ii)
- [94. 二叉树的中序遍历](#94-二叉树的中序遍历)
- [剑指 Offer 36. 二叉搜索树与双向链表](#剑指-offer-36-二叉搜索树与双向链表)
- [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
- [337. 打家劫舍 III](#337-打家劫舍-iii)

# [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

**题解一：递归**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int L = maxDepth(root->left);
        int R = maxDepth(root->right);
        return max(L, R) + 1;
    }
};
```

**题解二：BFS**

```C++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        queue<TreeNode*> que;
        que.push(root);
        int count = 0;
        while (!que.empty()) {
            count++;
            size_t n = que.size();
            while (n--) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return count;
    }
};
```

# [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：** 两结点之间的路径长度是以它们之间边的数目表示。

**题解一：递归**

在求深度的时候以每个节点为根的子树的最大直径`d = left+right`，对所有`d`取最大值

```C++
class Solution {
    int ans = 0;
    int depth(TreeNode* rt){
        if (rt == NULL) {
            return 0; // 访问到空节点了，返回0
        }
        int L = depth(rt->left); // 左儿子为根的子树的深度
        int R = depth(rt->right); // 右儿子为根的子树的深度
        ans = max(ans, L + R); // 计算d_node即L+R 并更新ans
        return max(L, R) + 1; // 返回该节点为根的子树的深度
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        depth(root);
        return ans;
    }
};
```

**题解二：面向对象思想**

对每个节点建立一个结构体，存储它的深度与最大半径

```C++
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        return process(root).maxDistance;
    }
    
    class info{
    public:
        info(int h, int m) {
            height = h;
            maxDistance = m;
        }
        int height, maxDistance;
    };
    
    info process(TreeNode* node) {
        if (node == NULL) {
            return info(0, 0);
        }
        info left = process(node->left);
        info right = process(node->right);
        int height = max(left.height, right.height) + 1;
        int d1 = max(left.maxDistance, right.maxDistance);
        int d2 = left.height + right.height;
        return info(height, max(d1, d2));
    }
    
};
```

# [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

**提示：**

- `1 <= n <= 19`

**题解一：动态规划（一）**

`dp[i]`代表节点数为`i`的二叉搜索数的种树，可以遍历其左子树与右子树的个数，利用前面确定的节点数对应的种树相乘计算当前结果

```C++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            int tmp = 0;
            for (int l = 0; l < i; l++) {
                int r = i - 1 - l;
                tmp += dp[l] * dp[r];
            }
            dp[i] = tmp;
        }
        return dp[n];
    }
};
```

**题解二：动态规划（二）**

```C++
 class Solution {
        /*
        dp[i] = i个不同的数组成的二叉搜索数的个数
        假设 i = 5
        当根节点等于 1 时 ，其余数字都比1大，只能在右边 dp[i] += dp[4]
        当根节点等于 2 时，左边有一个1比2小，右边有三个比2大的数字 dp[i] += dp[1] * dp[3]
        当根节点等于 3 时，左边有两个数比3小，右边有两个数比3大的数字 dp[i] += dp[2] * dp[2]
        ...
        知道根节点等于5，左边有4个数字比5小，只能放在5的左边,dp[i] += dp[4]
         */
        public int numTrees(int n) {
            int[] dp = new int[n + 1];
            dp[0] = 1;
            dp[1] = 1;
            for (int i = 2; i <= n; i++) {
                for (int j = 1; j <= i; j++) {
                    int leftNum = dp[j - 1];
                    int rightNum = dp[i - j];
                    dp[i] += leftNum * rightNum;
                }
            }
            return dp[n];
        }
    }
```

# [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

**提示：**

- 树中节点数目范围是 `[1, 3 * 104]`
- `-1000 <= Node.val <= 1000`

**题解一：后序遍历**

```C++
class Solution {
public:
    int res = INT_MIN;
    // 定义：计算从根节点 root 为起点的最大单边路径和
    int OneSideMax(TreeNode* root) {
        if (root == nullptr) return 0;
        int leftMaxSum = max(OneSideMax(root->left), 0);
        int rightMaxSum = max(OneSideMax(root->right), 0);
        int curMaxSum = leftMaxSum + rightMaxSum + root->val;
        // 后序遍历位置，顺便更新最大路径和
        res = max(res, curMaxSum);
        // 实现函数定义，左右子树的最大单边路径和加上根节点的值
        // 就是从根节点 root 为起点的最大单边路径和
        return max(leftMaxSum, rightMaxSum) + root->val;
    }
    int maxPathSum(TreeNode* root) {
        if (root == nullptr) return 0;
        // 计算单边路径和时顺便计算最大路径和
        OneSideMax(root);
        return res;
    }
};
```

# [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-109 <= Node.val <= 109`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

**题解一：递归**

若 *root* 是 *p, q* 的 **最近公共祖先** ，则只可能为以下情况之一：

1. *p* 和 *q* 在 *root* 的子树中，且分列 *root* 的 **异侧**（即分别在左、右子树中）；
1. *p* = *root* ，且 *q* 在 *root* 的左或右子树中；
1. *q* = *root* ，且 *p* 在 *root* 的左或右子树中；

考虑通过递归对二叉树进行先序遍历，当遇到节点 *p* 或 *q*  时返回。从底至顶回溯，当节点 *p, q*在节点 *root* 的异侧时，节点 *root*  即为最近公共祖先，则向上返回 *root* 。

```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if(left == nullptr && right == nullptr) return nullptr; // 1.
        if(left == nullptr) return right; // 3.
        if(right == nullptr) return left; // 4.
        return root; // 2. if(left != null and right != null)
    }
};
```

```C++
//情况 1. 可合并至 3. 和 4.
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if (root == nullptr) return right;
        if (right == nullptr) return left;
        return root; 
    }
};
```

# [剑指 Offer 26. 树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

```
     3
    / \
   4   5
  / \
 1   2
```

给定的树 B：

```
   4 
  /
 1
```

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

**示例 1：**

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

**示例 2：**

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

**限制：**

`0 <= 节点个数 <= 10000`

**题解一：递归**

```C++
class Solution {
public:
    // 这个函数用「遍历」的思维模式理解，遍历二叉树 A 的所有节点
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (A == nullptr || B == nullptr) {
            return false;
        }
        // 对于树 A 中的一个节点：
        // 1. 如果 A->val == B->val，则 A 可以作为根节点尝试去匹配树 B
        if (A->val == B->val && compareTree(A, B)) {
            return true;
        }
        // 2. 如果 A->val != B->val，就不要去匹配树 B 了
        return isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
    // 这个函数用「分解问题」的思路理解
    // 定义：输入两个根节点，返回从 rootA 开始是否可以完全匹配 rootB 树上的所有节点
    bool compareTree(TreeNode *rootA, TreeNode *rootB) {
        // base case
        if (rootB == nullptr) {
            return true;
        }
        if (rootA == nullptr) {
            return false;
        }
        if (rootA->val != rootB->val) {
            return false;
        }
        // rootA 的值和 rootB 的值匹配完成，去匹配子树的节点
        return compareTree(rootA->left, rootB->left) && compareTree(rootA->right, rootB->right);
    }

};
```

# [652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)

给定一棵二叉树 `root`，返回所有**重复的子树**。

对于同一类的重复子树，你只需要返回其中任意**一棵**的根结点即可。

如果两棵树具有**相同的结构**和**相同的结点值**，则它们是**重复**的。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/16/e1.jpg)

```
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/08/16/e2.jpg)

```
输入：root = [2,1,1]
输出：[[1]]
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/08/16/e33.jpg)

```
输入：root = [2,2,2,3,null,3,null]
输出：[[2,3],[3]]
```

**提示：**

- 树中的结点数在`[1,10^4]`范围内。
- `-200 <= Node.val <= 200`

**题解一：深度优先遍历**

```c++
class Solution {
public:
    unordered_map<string, int> map;
    vector<TreeNode*> res; 
    string dfs(TreeNode* root) {
        if (root == nullptr) return "#";
        string curPath = to_string(root->val) + "," + dfs(root->left) + "," + dfs(root->right);
        map[curPath]++;
        if (map[curPath] == 2) {
            res.push_back(root);
        }
        return curPath;
    }
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

**题解二：深度优先遍历（省空间版本）**

leetcode@[ffreturn](https://leetcode.cn/u/ffreturn/)

**主要思想是利用唯一的序号来代替一种子树结构**

子树是否相同的条件是

1. val相同
2. left和right的数值都是相同的

思路如下：

1. 采用深度优先的方式去遍历树
2. 去构建 包含 val,left,right 的子树的映射表， 同时这个子树需要一个编号去用于快速遍历（这里用递增的方式）
3. 构建子树编号的映射表，初始化为1，每次找到就+1，如果=2时候说明第一次发现有重复，则插入到结果里

```c++
class Solution {
private:
    // 结果的存储
    vector<TreeNode*> res;
    // 子树的编号，从1开始，用0表示是无效，后续递增来保证唯一
    int index = 1;
    // 子树 val,left,right的字符串 到唯一编号的映射
    unordered_map<string, int> str2index;
    // 唯一编号 到 数量的映射
    // unordered_map<int, int> index2cnt;
    // 这里假设是优先编号，如5000已满足测试需求来提速
    int index2cnt[5000];

    // 返回值为 当前节点对应的 唯一编号
    int dfs(TreeNode* curr)
    {
        if (curr != nullptr)
        {
            string currStr = to_string(curr->val) + "," + to_string(dfs(curr->left)) + "," + 	to_string(dfs(curr->right));
            if (str2index.find(currStr) == str2index.end())
            {
                str2index[currStr] = index;
                ++index;
            }
            int index = str2index[currStr];
            ++index2cnt[index];
            // 首次发现重复，增加结果里
            if (index2cnt[index] == 2)
            {
                res.push_back(curr);
            }
            return index;
        }
        else
        {
            return 0;
        }
    }

public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        dfs(root);
        memset(index2cnt, 0, sizeof(int) * 5000);
        return res;
    }
};

```

# [95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)

给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** 。可以按 **任意顺序** 返回答案。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

**提示：**

- `1 <= n <= 8`

**题解一：递归**

```C++
class Solution {
public:
    /* 构造闭区间 [lo, hi] 组成的 BST */
    vector<TreeNode*> build(int lo, int hi) {
        vector<TreeNode*> res;
        // base case
        if (lo > hi) {
            res.push_back(nullptr);
            return res;
        }
        // 1、穷举 root 节点的所有可能。
        for (int i = lo; i <= hi; i++) {
            // 2、递归构造出左右子树的所有合法 BST。
            vector<TreeNode*> leftTree = build(lo, i - 1);
            vector<TreeNode*> rightTree = build(i + 1, hi);           
            // 3、给 root 节点穷举所有左右子树的组合。
            for (auto l : leftTree) {
                for (auto r : rightTree) {
                    // i 作为根节点 root 的值
                    TreeNode* root = new TreeNode(i);
                    root->left = l;
                    root->right = r;
                    res.push_back(root);
                }
            }
        }
        return res;
    } 
    /* 主函数 */
    vector<TreeNode*> generateTrees(int n) {
        // 构造闭区间 [1, n] 组成的 BST
        return build(1, n);
    }
}; 
```

# [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

**题解一：递归**

```c++
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& res) {
        if (!root)  return;
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        inorder(root, res);
        return res;
    }
};
```

**题解二：迭代**

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        if (root == nullptr) return res;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
```

**题解三：统一迭代法（nullptr作访问标记）**

```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (root == nullptr) return ans;
        stack<TreeNode*> st; 
        st.push(root);
        while (!st.empty()) {
            TreeNode* cur = st.top();
            if (cur != nullptr) {
                st.pop();
                if (cur->right) st.push(cur->right);
                st.push(cur);
                st.push(nullptr);
                if (cur->left) st.push(cur->left);
            } else {
                st.pop();
                cur = st.top();
                ans.push_back(cur->val);
                st.pop();
            }
        }
        return ans;
    }
};
```

**题解四：统一迭代法（pair作访问标记）**

```C++
//以pair.second来标记什么时候访问元素
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<pair<TreeNode*, int> > stk;
        stk.push((make_pair(root, 0)));
        
        while(!stk.empty()) {
            auto [node, type] = stk.top();
            stk.pop();
            if(node == nullptr) continue;
            if(type == 0) {
                stk.push(make_pair(node->right, 0));
                stk.push(make_pair(node, 1));
                stk.push(make_pair(node->left, 0));
            }
            else result.emplace_back(node->val);
        }

        return result;

    }
};
```

# [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

为了让您更好地理解问题，以下面的二叉搜索树为例：

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png)

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

**题解一：宏观递归**

```C++
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if (!root) return root;
        Node* leftHead = treeToDoublyList(root->left);
        Node* rightHead = treeToDoublyList(root->right);
        Node* leftTail, *rightTail;
        if (leftHead) {
            leftTail = leftHead->left;
            leftTail->right = root;
            root->left = leftTail;
        } else {
            leftTail = leftHead = root;
        }
        if (rightHead) {
            rightTail = rightHead->left;
            root->right = rightHead;
            rightHead->left = root;
        } else {
            rightTail = rightHead = root;
        }
        leftHead->left = rightTail;
        rightTail->right = leftHead;
        return leftHead;       
    }
};
```

**题解二：中序遍历**

```C++
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if (!root) return NULL;
        dfs(root);
        head->left = pre;
        pre->right = head;
        return head;      
    }
private: 
    Node* pre, *head;
    void dfs(Node* node) {
        if (!node) return;
        dfs(node->left);
        if (pre != NULL) pre->right = node;
        else head = node;
        node->left = pre;
        pre = node;
        dfs(node->right);
    }
};
```

# [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

**题解一：迭代（广度优先遍历）**

```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if (root == nullptr) return ans;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int n = que.size();
            vector<int> cur_floor;
            while (n--) {
                TreeNode* cur = que.front();
                que.pop();
                cur_floor.push_back(cur->val);
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            ans.push_back(cur_floor);
        }
        return ans;
    }
};
```

**题解二：递归（深度优先遍历）**

```C++
class Solution {
public:
    vector<vector<int>> ans;
    void traversal(TreeNode* node, int layer) {
        if (!node) return;
        if (ans.size() == layer) ans.push_back(vector<int>());
        ans[layer].push_back(node->val);
        traversal(node->left, layer + 1);
        traversal(node->right, layer + 1); 
    }
    vector<vector<int>> levelOrder(TreeNode* root) {       
        traversal(root, 0);
        return ans;
    }
};
```

# [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)

```
输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
```

**提示：**

- 树的节点数在 `[1, 104]` 范围内
- `0 <= Node.val <= 104`
