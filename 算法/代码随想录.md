- [数组](#数组)
  - [二分查找](#二分查找)
    - [704. 二分查找](#704-二分查找)
    - [35. 搜索插入位置](#35-搜索插入位置)
    - [34. 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置)
    - [69. x 的平方根 ](#69-x-的平方根-)
    - [367. 有效的完全平方数](#367-有效的完全平方数)
  - [移除元素](#移除元素)
    - [27. 移除元素](#27-移除元素)
    - [26. 删除有序数组中的重复项](#26-删除有序数组中的重复项)
    - [283. 移动零](#283-移动零)
    - [844. 比较含退格的字符串](#844-比较含退格的字符串)
  - [977. 有序数组的平方](#977-有序数组的平方)
  - [长度最小的子数组](#长度最小的子数组)
    - [209. 长度最小的子数组](#209-长度最小的子数组)
    - [904. 水果成篮](#904-水果成篮)
    - [76. 最小覆盖子串](#76-最小覆盖子串)
# 数组

## 二分查找

### [704. 二分查找](https://leetcode.cn/problems/binary-search/)

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

**解法一：二分**

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int mid;
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
};
```

### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例 1:**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2:**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3:**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

**提示:**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 为 **无重复元素** 的 **升序** 排列数组
- `-104 <= target <= 104`

**解法一：二分**

注意判断`nums[mid]`和`target`时，如果`nums[mid] < targe`则更新`left`，如果`nums[mid] >= target`，则更新`right`，这样保证了如果存在`target`，退出`while`循环时`left`就指向`target`，如果不存在`target`，退出`while`循环后`left`指向了`target`应该被插入的位置

```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int mid;
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else right = mid - 1;
        }
        return left;
    }
};
```

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- `nums` 是一个非递减数组
- `-109 <= target <= 109`

**解法一：二分定位，两侧蔓延**

利用二分寻找`target`，如果找不到直接返回，如果找到了，从`target`的位置向两边扩散，找到`target`的左右边界

```C++
//时间复杂度为O(n)
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> ans(2, -1);
        int l = 0, r = nums.size() - 1;
        int mid, start, end;
        while (l <= r) {
            mid = l + (r - l) / 2;
            if (nums[mid] == target) {
                start = mid;
                end = mid;
                ans[0] = start, ans[1] = end;
                while (nums[start] == target) {
                    ans[0] = start;
                    start--;
                    if (start < 0) break;                   
                }
                while (nums[end] == target) {
                    ans[1] = end;
                    end++;
                    if (end > (nums.size() - 1)) break;
                }
                return ans;
            } else if (nums[mid] > target) {
                r = mid - 1;
            } else l = mid + 1;
        }
        return ans;
    }
};
```

**解法二：二分寻找左右边界**

如果是求左边界，当`nums[mid] == target`时，先记录当前`mid`的值，然后`right = mid - 1`

如果是求右边界，当`nums[mid] == target`时，先记录当前`mid`的值，然后`left = mid + 1`

```C++
//时间复杂度为O(log(n))
class Solution {
    int twoDivideSearch(vector<int>& nums, int target, bool flag)
    {
        int left = 0, right = nums.size() - 1, mid, res = -1;
        while(left <= right) {
            mid = left + (right - left) / 2;
            if(nums[mid] == target) {
                res = mid;
                if(flag) {
                    right = mid - 1; //flag为真，求左区间
                } else {
                    left = mid + 1; //flag为假，求右区间
                }      
            }
            else if (nums[mid] < target) 
                left = mid + 1;
            else
                right = mid - 1;
        }
        return res;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = twoDivideSearch(nums, target, true);
        int right = twoDivideSearch(nums, target, false);
        if(nums.empty() || (left == -1 && right == -1)) {
            return vector<int>{-1, -1};
        }  
        return vector<int>{left, right};
    }
};
```

### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

**示例 1：**

```
输入：x = 4
输出：2
```

**示例 2：**

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

**提示：**

- `0 <= x <= 231 - 1`

**解法一：二分**

```c++
class Solution {
public:
    int mySqrt(int x) {
        int l = 0, r = x;
        int mid, ans;
        while (l <= r) {
            mid = l + (r - l) / 2;
            if ((long long)mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            } 
        }
        return ans;
    }
};
```

### [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

给定一个 **正整数** `num` ，编写一个函数，如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**进阶：不要** 使用任何内置的库函数，如 `sqrt` 。

**示例 1：**

```
输入：num = 16
输出：true
```

**示例 2：**

```
输入：num = 14
输出：false
```

**提示：**

- `1 <= num <= 2^31 - 1`

**解法一：二分**

```C++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int l = 0, r = num;
        int mid;
        while (l <= r) {
            mid = l + (r - l) / 2;
            if ((long long)mid * mid > num) {
                r = mid - 1;
            } else if ((long long)mid * mid < num) {
                l = mid + 1;
            } else {
                return true;
            }
        }
        return false;
    }
};
```

## 移除元素

### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

**题解一：双指针**

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = 0;
        for (; right < nums.size(); right++) {
            if (nums[right] != val) {
                nums[left++] = nums[right];
            }
        }
        return left;
    }
};
```

### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。

将最终结果插入 `nums` 的前 `k` 个位置后返回 `k` 。

不要使用额外的空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

**判题标准:**

系统会用下面的代码来测试你的题解:

```
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有断言都通过，那么您的题解将被 **通过**。

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **升序** 排列

**题解一：双指针**

```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size(); 
        if (n == 0) return 0;
        int j = 0;
        for (int i = 1; i < n; i++) {
            if (nums[j] != nums[i]) {
                nums[++j] = nums[i];
            }
        }
        return j + 1;
    }
};
```

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

**提示**:

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`

**进阶：**你能尽量减少完成的操作次数吗？

**题解一：双指针**

思想：将数组后面非零元素移动至数组前面，后面置零

```C++
//时间复杂度O(N)
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
       int j = 0;
       for (int i = 0; i < nums.size(); i++) {
           if (nums[i] != 0) {
               nums[j++] = nums[i];
           }
       }
       for (int i = j; i < nums.size(); i++) {
           nums[i] = 0;
       }
    }
};
```

**题解二：双指针**

思想：将数组非零元素与零元素进行交换，交换后非零元素位于数组前半部分，零元素位于后半部分

```C++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
       int l = 0, r = 0;
       while (r < nums.size()) {
           if (nums[r]) {  //遇到零元素后l指针不变，等待r指针遇到非零元素后进行交换
               swap(nums[l], nums[r]);
               l++;  
           }
           r++;
       }
    }
};
```

### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

**示例 1：**

```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

**示例 2：**

```
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

**示例 3：**

```
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```

**提示：**

- `1 <= s.length, t.length <= 200`
- `s` 和 `t` 只含有小写字母以及字符 `'#'`

**进阶：**

- 你可以用 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？

**题解一：重建字符串**

思路：遇到非`#`就加入字符串，遇到`#`且字符串非空就弹出最后一个字符，构建两个新的字符串进行比较，此方法使用了额外空间，非最优解

```C++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        if (build(s) == build(t)) {
            return true;
        } else {
            return false;
        }
    }
private:
    string build(string s) {
        string m;
        for (char ch : s) {
            if (ch != '#') {
                m.push_back(ch);
            } else if (!m.empty()) {
                m.pop_back();
            }
        }
        return m;
    }
};
```

**题解二：双指针**

思路：利用双指针在原字符串得到新的字符串进行比较。

遇到字母两指针都向前一位，遇到#号快指针向前一位，慢指针后退一位(注意0位置)

```C++
//时间复杂度为O(N)
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int counts = backString(s);
        int countt = backString(t);
        if (counts != countt) {
            return false;
        } else {
            for (int i = 0; i < counts; i++) {
                if (s[i] != t[i]) {
                    return false;
                }
            }
        }
        return true;
    }
private:
    int backString(string &s) {
        int i = 0, j = 0;
        int n = s.size();
        while (i < n) {
            if (s[i] != '#') {
                s[j++] = s[i++];
            } else if (s[i] == '#') {
                if (j > 0) j--;
                i++;
            }
        }
        return j;
    }
};
```

## [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

**提示：**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **非递减顺序** 排序

**进阶：**

- 请你设计时间复杂度为 `O(n)` 的算法解决本问题

**题解一：双指针**

思路：新建一个等长数组`res`，比较`nums`头尾绝对值，将较大的数平方后填到`res`后面

```C++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        int left = 0, right = n - 1;
        int count = n - 1;
        while (left <= right) {
            if (abs(nums[right]) >= abs(nums[left])) {
                res[count--] = nums[right] * nums[right];
                right--;
            } else {
                res[count--] = nums[left] * nums[left];
                left++;
            }
        }
        return res;
    }
};
```

## 长度最小的子数组

### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl,``numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

**题解一：滑动窗口**

思路：如果当前窗口内数字和小于`target`，窗口右指针右移；如果当前窗口内数字和大于`target`，窗口左指针左移直至窗口内数字之和小于`target`，再向右移动窗口右指针，重复上述操作。注意在窗口变化过程中更新满足条件的最小`length`。

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int minLength = INT32_MAX;
        bool tag = false;
        int i = 0, sum = 0, length = 0;
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            length++;
            while (sum >= target) {
                tag = true;
                minLength = min(length, minLength);
                sum -= nums[i++];
                length--;
            }
        }
        return tag ? minLength : 0;
    }
};
```

**题解二：前缀和 + 二分查找**

思路：为了使用二分查找，需要额外创建一个数组 `sums` 用于存储数组`nums` 的前缀和，其中 `sums[i]` 表示从 `nums[0]` 到`nums[i−1]` 的元素和。得到前缀和之后，对于每个开始下标 `i`，可通过二分查找得到大于或等于 `i` 的最小下标 `bound`，使得                    `sums[bound] − sums[i−1] ≥ s`，并更新子数组的最小长度（此时子数组的长度是 `bound − (i − 1)`）

```C++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        vector<int> sums(n + 1, 0); 
        // 为了方便计算，令 size = n + 1 
        // sums[0] = 0 意味着前 0 个元素的前缀和为 0
        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]
        // 以此类推
        for (int i = 1; i <= n; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }
        for (int i = 1; i <= n; i++) {
            int target = s + sums[i - 1];
            auto bound = lower_bound(sums.begin(), sums.end(), target);
            if (bound != sums.end()) {
                ans = min(ans, static_cast<int>((bound - sums.begin()) - (i - 1)));
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```

### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

**示例 1：**

```
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
```

**示例 2：**

```
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
```

**示例 3：**

```
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
```

**示例 4：**

```
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
```

**提示：**

- `1 <= fruits.length <= 105`
- `0 <= fruits[i] < fruits.length`

**题解一：滑窗法**

思路：当滑窗内的水果种类不超过2时，滑窗的右边界向右扩张，当滑窗内水果种类超过2后，滑窗的左边界向右收缩，直至滑窗内水果种类小于等于2，在滑窗动态变化的过程中更新`res`。

```C++
class Solution {
public:
    int totalFruit(vector<int>& tree) {
        unordered_map<int, int> window;
        const int k = 2;
        int res = 0;
        for (int left = 0, right = 0; right < tree.size(); right++) {
            window[tree[right]]++;
            while (window.size() > k) {
                window[tree[left]]--;    
                if (window[tree[left]] == 0) {
                    window.erase(tree[left]);
                }
                left++;
            }
            res = max(res, right - left + 1);
        }

        return res;
    }
};
```

**题解二：三指针**

思路：`f`指针指向第一种水果，`s`指向第二种水果，`tmp`指向即将成为第一种水果的水果；当遍历到的某个水果和当前的两种水果不同时，`tmp`所指的水果变为新的第一种水果，当前遍历到的水果成为新的第二种水果。

```C++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int f = 0, s = 0, tmp = 0;
        int len = 0;
        for (int i = 0; i < fruits.size(); i++) {
            if (fruits[i] != fruits[f] && fruits[i] != fruits[s]) {
                if (f != s) {
                    f = tmp;
                }
                s = i;
            }
            len = max(len, i - f + 1);
            if (fruits[tmp] != fruits[i]) {
                tmp = i;
            }
        }
        return len;
    }
};
```

### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

**提示：**

- `1 <= s.length, t.length <= 105`
- `s` 和 `t` 由英文字母组成

**进阶：**你能设计一个在 `o(n)` 时间内解决此问题的算法吗？

**题解一：滑动窗口**

思路：这道题要求我们返回字符串 `s`中包含字符串 `t` 的全部字符的最小窗口，我们利用滑动窗口的思想解决这个问题。因此我们需要两个哈希表，`hs`哈希表维护的是`s`字符串中滑动窗口中各个字符出现多少次，`ht`哈希表维护的是`t`字符串各个字符出现多少次。如果`hs`哈希表中包含`ht`哈希表中的所有字符，并且对应的个数都不小于`ht`哈希表中各个字符的个数，那么说明当前的窗口是可行的，可行中的长度最短的滑动窗口就是答案。

```C++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> hs, ht;
        for (auto c: t) ht[c] ++ ;
        string res;
        int cnt = 0;
        for (int i = 0, j = 0; i < s.size(); i ++ ) {
            hs[s[i]] ++ ;
            if (hs[s[i]] <= ht[s[i]]) cnt ++ ;

            while (hs[s[j]] > ht[s[j]]) hs[s[j ++ ]] -- ;
            if (cnt == t.size()) {
                if (res.empty() || i - j + 1 < res.size())
                    res = s.substr(j, i - j + 1);
            }
        }
        return res;
    }
};
```

