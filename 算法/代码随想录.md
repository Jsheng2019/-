- [数组](#数组)
  - [二分查找](#二分查找)
    - [704. 二分查找](#704-二分查找)
    - [35. 搜索插入位置](#35-搜索插入位置)
    - [34. 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置)
    - [69. x 的平方根 ](#69-x-的平方根-)
    - [367. 有效的完全平方数](#367-有效的完全平方数)
  - [移除元素](#移除元素)
    - [27. 移除元素](#27-移除元素)
    - [26. 删除有序数组中的重复项](#26-删除有序数组中的重复项)
    - [283. 移动零](#283-移动零)
    - [844. 比较含退格的字符串](#844-比较含退格的字符串)
  - [977. 有序数组的平方](#977-有序数组的平方)
  - [长度最小的子数组](#长度最小的子数组)
    - [209. 长度最小的子数组](#209-长度最小的子数组)
    - [904. 水果成篮](#904-水果成篮)
    - [76. 最小覆盖子串](#76-最小覆盖子串)
  - [螺旋矩阵](#螺旋矩阵)
    - [54. 螺旋矩阵](#54-螺旋矩阵)
    - [59. 螺旋矩阵 II](#59-螺旋矩阵-ii)
- [链表](#链表)
  - [203. 移除链表元素](#203-移除链表元素)
  - [707. 设计链表](#707-设计链表)
  - [206. 反转链表](#206-反转链表)
  - [24. 两两交换链表中的节点](#24-两两交换链表中的节点)
  - [19. 删除链表的倒数第 N 个结点](#19-删除链表的倒数第-n-个结点)
  - [160. 相交链表](#160-相交链表)
  - [142. 环形链表 II](#142-环形链表-ii)
- [哈希表](#哈希表)
  - [有效的字母异位词](#有效的字母异位词)
    - [242. 有效的字母异位词](#242-有效的字母异位词)
    - [383. 赎金信](#383-赎金信)
    - [49. 字母异位词分组](#49-字母异位词分组)
    - [438. 找到字符串中所有字母异位词](#438-找到字符串中所有字母异位词)
  - [两个数组的交集](#两个数组的交集)
    - [349. 两个数组的交集](#349-两个数组的交集)
    - [350. 两个数组的交集 II](#350-两个数组的交集-ii)
  - [202. 快乐数](#202-快乐数)
  - [1. 两数之和](#1-两数之和)
  - [454. 四数相加 II](#454-四数相加-ii)
  - [15. 三数之和](#15-三数之和)
  - [18. 四数之和](#18-四数之和)
- [字符串](#字符串)
  - [344. 反转字符串](#344-反转字符串)
  - [541. 反转字符串 II](#541-反转字符串-ii)
  - [剑指 Offer 05. 替换空格](#剑指-offer-05-替换空格)
  - [151. 反转字符串中的单词](#151-反转字符串中的单词)
  - [剑指 Offer 58 - II. 左旋转字符串](#剑指-offer-58---ii-左旋转字符串)
  - [28. 找出字符串中第一个匹配项的下标](#28-找出字符串中第一个匹配项的下标)
  - [459. 重复的子字符串](#459-重复的子字符串)
- [双指针](#双指针)
  - [移除元素](#移除元素-1)
    - [27. 移除元素](#27-移除元素-1)
    - [26. 删除有序数组中的重复项](#26-删除有序数组中的重复项-1)
    - [283. 移动零](#283-移动零-1)
    - [844. 比较含退格的字符串](#844-比较含退格的字符串-1)
    - [977. 有序数组的平方](#977-有序数组的平方-1)
  - [344. 反转字符串](#344-反转字符串-1)
  - [剑指 Offer 05. 替换空格](#剑指-offer-05-替换空格-1)
  - [151. 反转字符串中的单词](#151-反转字符串中的单词-1)
  - [206. 反转链表](#206-反转链表-1)
  - [19. 删除链表的倒数第 N 个结点](#19-删除链表的倒数第-n-个结点-1)
  - [面试题 02.07. 链表相交](#面试题-0207-链表相交)
  - [142. 环形链表 II](#142-环形链表-ii-1)
# 数组

## 二分查找

### [704. 二分查找](https://leetcode.cn/problems/binary-search/)

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

**解法一：二分**

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int mid;
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
};
```

### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例 1:**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2:**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3:**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

**提示:**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 为 **无重复元素** 的 **升序** 排列数组
- `-104 <= target <= 104`

**解法一：二分**

注意判断`nums[mid]`和`target`时，如果`nums[mid] < targe`则更新`left`，如果`nums[mid] >= target`，则更新`right`，这样保证了如果存在`target`，退出`while`循环时`left`就指向`target`，如果不存在`target`，退出`while`循环后`left`指向了`target`应该被插入的位置

```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int mid;
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else right = mid - 1;
        }
        return left;
    }
};
```

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- `nums` 是一个非递减数组
- `-109 <= target <= 109`

**解法一：二分定位，两侧蔓延**

利用二分寻找`target`，如果找不到直接返回，如果找到了，从`target`的位置向两边扩散，找到`target`的左右边界

```C++
//时间复杂度为O(n)
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> ans(2, -1);
        int l = 0, r = nums.size() - 1;
        int mid, start, end;
        while (l <= r) {
            mid = l + (r - l) / 2;
            if (nums[mid] == target) {
                start = mid;
                end = mid;
                ans[0] = start, ans[1] = end;
                while (nums[start] == target) {
                    ans[0] = start;
                    start--;
                    if (start < 0) break;                   
                }
                while (nums[end] == target) {
                    ans[1] = end;
                    end++;
                    if (end > (nums.size() - 1)) break;
                }
                return ans;
            } else if (nums[mid] > target) {
                r = mid - 1;
            } else l = mid + 1;
        }
        return ans;
    }
};
```

**解法二：二分寻找左右边界**

如果是求左边界，当`nums[mid] == target`时，先记录当前`mid`的值，然后`right = mid - 1`

如果是求右边界，当`nums[mid] == target`时，先记录当前`mid`的值，然后`left = mid + 1`

```C++
//时间复杂度为O(log(n))
class Solution {
    int twoDivideSearch(vector<int>& nums, int target, bool flag)
    {
        int left = 0, right = nums.size() - 1, mid, res = -1;
        while(left <= right) {
            mid = left + (right - left) / 2;
            if(nums[mid] == target) {
                res = mid;
                if(flag) {
                    right = mid - 1; //flag为真，求左区间
                } else {
                    left = mid + 1; //flag为假，求右区间
                }      
            }
            else if (nums[mid] < target) 
                left = mid + 1;
            else
                right = mid - 1;
        }
        return res;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = twoDivideSearch(nums, target, true);
        int right = twoDivideSearch(nums, target, false);
        if(nums.empty() || (left == -1 && right == -1)) {
            return vector<int>{-1, -1};
        }  
        return vector<int>{left, right};
    }
};
```

### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

**示例 1：**

```
输入：x = 4
输出：2
```

**示例 2：**

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

**提示：**

- `0 <= x <= 231 - 1`

**解法一：二分**

```c++
class Solution {
public:
    int mySqrt(int x) {
        int l = 0, r = x;
        int mid, ans;
        while (l <= r) {
            mid = l + (r - l) / 2;
            if ((long long)mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            } 
        }
        return ans;
    }
};
```

### [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

给定一个 **正整数** `num` ，编写一个函数，如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**进阶：不要** 使用任何内置的库函数，如 `sqrt` 。

**示例 1：**

```
输入：num = 16
输出：true
```

**示例 2：**

```
输入：num = 14
输出：false
```

**提示：**

- `1 <= num <= 2^31 - 1`

**解法一：二分**

```C++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int l = 0, r = num;
        int mid;
        while (l <= r) {
            mid = l + (r - l) / 2;
            if ((long long)mid * mid > num) {
                r = mid - 1;
            } else if ((long long)mid * mid < num) {
                l = mid + 1;
            } else {
                return true;
            }
        }
        return false;
    }
};
```

## 移除元素

### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

**题解一：双指针**

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = 0;
        for (; right < nums.size(); right++) {
            if (nums[right] != val) {
                nums[left++] = nums[right];
            }
        }
        return left;
    }
};
```

### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。

将最终结果插入 `nums` 的前 `k` 个位置后返回 `k` 。

不要使用额外的空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

**判题标准:**

系统会用下面的代码来测试你的题解:

```
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有断言都通过，那么您的题解将被 **通过**。

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **升序** 排列

**题解一：双指针**

```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size(); 
        if (n == 0) return 0;
        int j = 0;
        for (int i = 1; i < n; i++) {
            if (nums[j] != nums[i]) {
                nums[++j] = nums[i];
            }
        }
        return j + 1;
    }
};
```

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

**提示**:

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`

**进阶：**你能尽量减少完成的操作次数吗？

**题解一：双指针**

思想：将数组后面非零元素移动至数组前面，后面置零

```C++
//时间复杂度O(N)
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
       int j = 0;
       for (int i = 0; i < nums.size(); i++) {
           if (nums[i] != 0) {
               nums[j++] = nums[i];
           }
       }
       for (int i = j; i < nums.size(); i++) {
           nums[i] = 0;
       }
    }
};
```

**题解二：双指针**

思想：将数组非零元素与零元素进行交换，交换后非零元素位于数组前半部分，零元素位于后半部分

```C++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
       int l = 0, r = 0;
       while (r < nums.size()) {
           if (nums[r]) {  //遇到零元素后l指针不变，等待r指针遇到非零元素后进行交换
               swap(nums[l], nums[r]);
               l++;  
           }
           r++;
       }
    }
};
```

### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

**示例 1：**

```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

**示例 2：**

```
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

**示例 3：**

```
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```

**提示：**

- `1 <= s.length, t.length <= 200`
- `s` 和 `t` 只含有小写字母以及字符 `'#'`

**进阶：**

- 你可以用 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？

**题解一：重建字符串**

思路：遇到非`#`就加入字符串，遇到`#`且字符串非空就弹出最后一个字符，构建两个新的字符串进行比较，此方法使用了额外空间，非最优解

```C++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        if (build(s) == build(t)) {
            return true;
        } else {
            return false;
        }
    }
private:
    string build(string s) {
        string m;
        for (char ch : s) {
            if (ch != '#') {
                m.push_back(ch);
            } else if (!m.empty()) {
                m.pop_back();
            }
        }
        return m;
    }
};
```

**题解二：双指针**

思路：利用双指针在原字符串得到新的字符串进行比较。

遇到字母两指针都向前一位，遇到#号快指针向前一位，慢指针后退一位(注意0位置)

```C++
//时间复杂度为O(N)
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int counts = backString(s);
        int countt = backString(t);
        if (counts != countt) {
            return false;
        } else {
            for (int i = 0; i < counts; i++) {
                if (s[i] != t[i]) {
                    return false;
                }
            }
        }
        return true;
    }
private:
    int backString(string &s) {
        int i = 0, j = 0;
        int n = s.size();
        while (i < n) {
            if (s[i] != '#') {
                s[j++] = s[i++];
            } else if (s[i] == '#') {
                if (j > 0) j--;
                i++;
            }
        }
        return j;
    }
};
```

## [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

**提示：**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **非递减顺序** 排序

**进阶：**

- 请你设计时间复杂度为 `O(n)` 的算法解决本问题

**题解一：双指针**

思路：新建一个等长数组`res`，比较`nums`头尾绝对值，将较大的数平方后填到`res`后面

```C++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        int left = 0, right = n - 1;
        int count = n - 1;
        while (left <= right) {
            if (abs(nums[right]) >= abs(nums[left])) {
                res[count--] = nums[right] * nums[right];
                right--;
            } else {
                res[count--] = nums[left] * nums[left];
                left++;
            }
        }
        return res;
    }
};
```

## 长度最小的子数组

### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl,``numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

**题解一：滑动窗口**

思路：如果当前窗口内数字和小于`target`，窗口右指针右移；如果当前窗口内数字和大于`target`，窗口左指针左移直至窗口内数字之和小于`target`，再向右移动窗口右指针，重复上述操作。注意在窗口变化过程中更新满足条件的最小`length`。

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int minLength = INT32_MAX;
        bool tag = false;
        int i = 0, sum = 0, length = 0;
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            length++;
            while (sum >= target) {
                tag = true;
                minLength = min(length, minLength);
                sum -= nums[i++];
                length--;
            }
        }
        return tag ? minLength : 0;
    }
};
```

**题解二：前缀和 + 二分查找**

思路：为了使用二分查找，需要额外创建一个数组 `sums` 用于存储数组`nums` 的前缀和，其中 `sums[i]` 表示从 `nums[0]` 到`nums[i−1]` 的元素和。得到前缀和之后，对于每个开始下标 `i`，可通过二分查找得到大于或等于 `i` 的最小下标 `bound`，使得                    `sums[bound] − sums[i−1] ≥ s`，并更新子数组的最小长度（此时子数组的长度是 `bound − (i − 1)`）

```C++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        vector<int> sums(n + 1, 0); 
        // 为了方便计算，令 size = n + 1 
        // sums[0] = 0 意味着前 0 个元素的前缀和为 0
        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]
        // 以此类推
        for (int i = 1; i <= n; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }
        for (int i = 1; i <= n; i++) {
            int target = s + sums[i - 1];
            auto bound = lower_bound(sums.begin(), sums.end(), target);
            if (bound != sums.end()) {
                ans = min(ans, static_cast<int>((bound - sums.begin()) - (i - 1)));
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```

### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

**示例 1：**

```
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
```

**示例 2：**

```
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
```

**示例 3：**

```
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
```

**示例 4：**

```
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
```

**提示：**

- `1 <= fruits.length <= 105`
- `0 <= fruits[i] < fruits.length`

**题解一：滑窗法**

思路：当滑窗内的水果种类不超过2时，滑窗的右边界向右扩张，当滑窗内水果种类超过2后，滑窗的左边界向右收缩，直至滑窗内水果种类小于等于2，在滑窗动态变化的过程中更新`res`。

```C++
class Solution {
public:
    int totalFruit(vector<int>& tree) {
        unordered_map<int, int> window;
        const int k = 2;
        int res = 0;
        for (int left = 0, right = 0; right < tree.size(); right++) {
            window[tree[right]]++;
            while (window.size() > k) {
                window[tree[left]]--;    
                if (window[tree[left]] == 0) {
                    window.erase(tree[left]);
                }
                left++;
            }
            res = max(res, right - left + 1);
        }

        return res;
    }
};
```

**题解二：三指针**

思路：`f`指针指向第一种水果，`s`指向第二种水果，`tmp`指向即将成为第一种水果的水果；当遍历到的某个水果和当前的两种水果不同时，`tmp`所指的水果变为新的第一种水果，当前遍历到的水果成为新的第二种水果。

```C++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int f = 0, s = 0, tmp = 0;
        int len = 0;
        for (int i = 0; i < fruits.size(); i++) {
            if (fruits[i] != fruits[f] && fruits[i] != fruits[s]) {
                if (f != s) {
                    f = tmp;
                }
                s = i;
            }
            len = max(len, i - f + 1);
            if (fruits[tmp] != fruits[i]) {
                tmp = i;
            }
        }
        return len;
    }
};
```

### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

**提示：**

- `1 <= s.length, t.length <= 105`
- `s` 和 `t` 由英文字母组成

**进阶：**你能设计一个在 `o(n)` 时间内解决此问题的算法吗？

**题解一：滑动窗口**

思路：这道题要求我们返回字符串 `s`中包含字符串 `t` 的全部字符的最小窗口，我们利用滑动窗口的思想解决这个问题。因此我们需要两个哈希表，`hs`哈希表维护的是`s`字符串中滑动窗口中各个字符出现多少次，`ht`哈希表维护的是`t`字符串各个字符出现多少次。如果`hs`哈希表中包含`ht`哈希表中的所有字符，并且对应的个数都不小于`ht`哈希表中各个字符的个数，那么说明当前的窗口是可行的，可行中的长度最短的滑动窗口就是答案。

```C++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> hs, ht;
        for (auto c: t) ht[c] ++ ;
        string res;
        int cnt = 0;
        for (int i = 0, j = 0; i < s.size(); i ++ ) {
            hs[s[i]] ++ ;
            if (hs[s[i]] <= ht[s[i]]) cnt ++ ;

            while (hs[s[j]] > ht[s[j]]) hs[s[j ++ ]] --;
            if (cnt == t.size()) {
                if (res.empty() || i - j + 1 < res.size())
                    res = s.substr(j, i - j + 1);
            }
        }
        return res;
    }
};
```

## 螺旋矩阵

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 10`
- `-100 <= matrix[i][j] <= 100`

**题解一：模拟**

思路：定义四个边界值，每次向一个方向遍历，遍历后更新对应的边界值，当两个边界关系不满足要求时退出循环

```C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector <int> ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案
        int u = 0; //赋值上下左右边界
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;
        while(true)
        {
            for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]); //向右移动直到最右
            if(++ u > d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); //向下
            if(-- r < l) break; //重新设定有边界
            for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); //向左
            if(-- d < u) break; //重新设定下边界
            for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); //向上
            if(++ l > r) break; //重新设定左边界
        }
        return ans;
    }
};
```

### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

**提示：**

- `1 <= n <= 20`

**题解一：模拟**

思路：@[Krahets](https://leetcode.cn/u/jyd/)

生成一个 `n×n` 空矩阵 `mat`，随后模拟整个向内环绕的填入过程：

- 定义当前左右上下边界 `l,r,t,b`，初始值 `num = 1`，迭代终止值 `tar = n * n`；
- 当 `num <= tar` 时，始终按照 `从左到右` `从上到下` `从右到左` `从下到上` 填入顺序循环，每次填入后：
- 执行 `num += 1`：得到下一个需要填入的数字；
- 更新边界：例如从左到右填完后，上边界` t += 1`，相当于上边界向内缩 1。
- 使用`num <= tar`而不是`l < r || t < b`作为迭代条件，是为了解决当`n`为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。
- 最终返回 `mat` 即可。

![Picture1.png](https://pic.leetcode-cn.com/ccff416fa39887c938d36fec8e490e1861813d3bba7836eda941426f13420759-Picture1.png)

```C++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> ans(n, vector<int>(n, 0));
        int l = 0, r = n - 1, t = 0, b = n - 1;
        int num = 1, tar = n * n;
        while (num <= tar) {
            for (int i = l; i <= r; i++) ans[t][i] = num++;
            t++;
            for (int i = t; i <= b; i++) ans[i][r] = num++;
            r--;
            for (int i = r; i >= l; i--) ans[b][i] = num++;
            b--;
            for (int i = b; i >= t; i--) ans[i][l] = num++;
            l++;
        }
        return ans;
    }
};
```

# 链表

## [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

**示例 2：**

```
输入：head = [], val = 1
输出：[]
```

**示例 3：**

```
输入：head = [7,7,7,7], val = 7
输出：[]
```

**提示：**

- 列表中的节点数目在范围 `[0, 104]` 内
- `1 <= Node.val <= 50`
- `0 <= val <= 50`

**题解一：递归**

```C++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (head == nullptr) return head;
        if (head->val == val) {
            return removeElements(head->next, val);
        } else {
            head->next = removeElements(head->next, val);
            return head;
        }
    }
};
```

**题解二：迭代**

```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (head == nullptr) return head;
        ListNode* dummy = new ListNode();
        dummy->next = head;
        ListNode* cur = dummy;
        while (cur->next != nullptr) {
            if (cur->next->val == val) {
                cur->next = cur->next->next;
            } else {
                cur = cur->next;
            }
        }
        return dummy->next;
    }
};
```

## [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：

- `get(index)`：获取链表中第 `index` 个节点的值。如果索引无效，则返回`-1`。
- `addAtHead(val)`：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点。
- `addAtTail(val)`：将值为 `val` 的节点追加到链表的最后一个元素。
- `addAtIndex(index,val)`：在链表中的第 `index` 个节点之前添加值为 `val`  的节点。如果 `index` 等于链表的长度，则该节点将附加到链表的末尾。如果 `index` 大于链表长度，则不会插入节点。如果`index`小于0，则在头部插入节点。
- `deleteAtIndex(index)`：如果索引 `index` 有效，则删除链表中的第 `index` 个节点。

**示例：**

```
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-> 3
linkedList.get(1);            //返回3
```

**提示：**

- 所有`val`值都在 `[1, 1000]` 之内。
- 操作次数将在 `[1, 1000]` 之内。
- 请不要使用内置的 LinkedList 库。

**题解一：**

```c++
class MyLinkedList {
public:
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int x) : val(x), next(nullptr) {}
        };

    MyLinkedList() {
        dummyhead = new LinkedNode(0);
        size = 0;
    }
    
    int get(int index) {
        if (index > (size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = dummyhead->next;
        while (index--) {
            cur = cur->next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = dummyhead->next;
        dummyhead->next = newNode;
        size++;
    }
    
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = dummyhead;
        while (cur->next != nullptr) {
            cur = cur->next;
        }
        cur->next = newNode;
        size++;
    }
    
    void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = dummyhead;
        while (index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        size++;
    }
    
    void deleteAtIndex(int index) {
        if (index >= size || index < 0) {
            return;
        }
        LinkedNode* cur = dummyhead;
        while(index--) {
            cur = cur->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        size--;
    }
private:
    int size;
    LinkedNode* dummyhead;
};
```

## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

**提示：**

- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`
- **进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

**题解一：递归（好理解版本）**

```c++
class Solution {
public:
    ListNode* reverse(ListNode* pre, ListNode* head) {
        if (head == nullptr) return pre;  //递归出口不要忘记
        ListNode* tmp = head->next;
        head->next = pre;
        pre = head;
        return reverse(pre, tmp);
    }
    ListNode* reverseList(ListNode* head) {
        return reverse(nullptr, head);
    }
};
```

**题解二：递归（不好理解版本）**

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;
        ListNode* ret = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;  //别忘了给当前最后节点next置空
        return ret;   //每次返回的都是最后一个节点
    }
};
```

**题解三：迭代**

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr) return head;
        ListNode* pre = nullptr;
        while (head != nullptr) {
            ListNode* tmp = head->next;
            head->next = pre;
            pre = head;
            head = tmp;
        }
        return pre;
    }
};
```

## [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

**题解一：迭代**

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == NULL || head->next == NULL) return head;
        ListNode* dummyHead = new ListNode();
        dummyHead->next = head;
        ListNode* cur = dummyHead;
        while (cur->next != NULL && cur->next->next != NULL) {
            ListNode* tmp1 = cur->next;
            ListNode* tmp2 = cur->next->next;
            tmp1->next = tmp2->next;
            cur->next = tmp2;
            tmp2->next = tmp1;
            cur = tmp1;
        }
        return dummyHead->next;
    }
};
```

**题解二：递归**

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == NULL || head->next == NULL) return head;
        ListNode* tmp = head->next;
        head->next = swapPairs(head->next->next);
        tmp->next = head;
        return tmp;
    }
};
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

**进阶：**你能尝试使用一趟扫描实现吗？

**题解一：双指针**

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode();
        dummy->next = head;
        ListNode* p1 = dummy;
        ListNode* p2 = dummy;
        for (int i = 0; i < n; ++i) {
            p1 = p1->next;
        }
        while (p1->next != nullptr) {
            p1 = p1->next;
            p2 = p2->next;
        }
        ListNode* tmp = p2->next;
        p2->next = p2->next->next;
        delete(tmp);
        return dummy->next;
    }
};
```

**题解二：递归**

```C++
class Solution {
public:
    int dfs(ListNode* head, int n) {
        if (head == nullptr) return 0;
        int cnt = dfs(head->next, n);
        if (cnt == n) {
            head->next = head->next->next;
        }
        return cnt + 1;
    }
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int cnt = dfs(head, n);
        if (cnt == n) {
            return head->next;
        }
        return head; 
    }
};
```

## [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**自定义评测：**

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
- `listA` - 第一个链表
- `listB` - 第二个链表
- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)

```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `1 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`

**进阶：**你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？

**题解一：双指针**

```C++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA;
        ListNode* curB = headB;
        while (curA != curB) {
            curA = curA == NULL ? headB : curA->next;
            curB = curB == NULL ? headA : curB->next; 
        }
        return curA;
    }
};
```

## [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

**提示：**

- 链表中节点的数目范围在范围 `[0, 104]` 内
- `-105 <= Node.val <= 105`
- `pos` 的值为 `-1` 或者链表中的一个有效索引

**进阶：**你是否可以使用 `O(1)` 空间解决此题？

**题解一：双指针**

```C++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {   
        ListNode* fast = head;
        ListNode* slow = head;
        do {
            if (fast == NULL || fast->next == NULL) return NULL;
            fast = fast->next->next;
            slow = slow->next;
        } while (fast != slow);
        fast = head;
        while (fast != slow) {
            fast = fast->next;
            slow = slow->next;
        }
        return fast;
    }
};
```

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (true) {
            if (fast == null || fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
}
```

# 哈希表

## 有效的字母异位词

### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**注意：**若 `s` 和 `t` 中每个字符出现的次数都相同，则称 `s` 和 `t` 互为字母异位词。

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

**提示:**

- `1 <= s.length, t.length <= 5 * 104`
- `s` 和 `t` 仅包含小写字母

**进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

**题解一：数组作哈希表**

思路：由于字母只有26位，可以用大小为26的数组作为哈希表来统计字母出现的频次

```C++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for (auto ch : s) {
            record[ch - 'a']++;
        }
        for (auto ch : t) {
            record[ch - 'a']--;
        }
        for (auto ch : record) {
            if (ch != 0) {
                return false;
            }
        }
        return true;    
    }
};
```

**题解二：排序**

思路：t 是 s 的异位词等价于「两个字符串排序后相等」。因此我们可以对字符串 s 和 t 分别排序，看排序后的字符串是否相等即可判断。此外，如果 s 和 t 的长度不同，t 必然不是 s 的异位词。

```C++
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.length() != t.length()) {
            return false;
        }
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return s == t;
    }
};
```

### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

**示例 1：**

```
输入：ransomNote = "a", magazine = "b"
输出：false
```

**示例 2：**

```
输入：ransomNote = "aa", magazine = "ab"
输出：false
```

**示例 3：**

```
输入：ransomNote = "aa", magazine = "aab"
输出：true
```

**提示：**

- `1 <= ransomNote.length, magazine.length <= 105`

- `ransomNote` 和 `magazine` 由小写英文字母组成

**题解一：数组作哈希表**

思路：要满足题目要求只要`magazine`中有`ransomNote`中出现的所有字符，并且`magazine`中出现的字符频次应大于等于在`ransomNote`中出现的频次

```C++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        for (auto ch : magazine) {
            record[ch - 'a']++;
        }
        for (auto ch : ransomNote) {
            record[ch - 'a']--;
            if (record[ch - 'a'] < 0) {
                return false;
            }
        }
        return true;
    }
};
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**示例 2:**

```
输入: strs = [""]
输出: [[""]]
```

**示例 3:**

```
输入: strs = ["a"]
输出: [["a"]]
```

**提示：**

- `1 <= strs.length <= 104`
- `0 <= strs[i].length <= 100`
- `strs[i]` 仅包含小写字母

**题解一：哈希表**

思路：本题的难点是如何将同一类字母异位词统计起来，同一个字母异位词排序后会得到相同的字符串，因此可以将排序后的字符串作为key，将同一类字母异位词作为value结合起来

```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> ans;
        unordered_map<string, vector<string>> record;
        for (auto s : strs) {
            string tmp = s;
            sort(tmp.begin(), tmp.end());
            record[tmp].push_back(s);
        }
        for (auto it : record) {
            ans.push_back(it.second);
        }
        return ans;
        
    }
};
```

### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

**提示:**

- `1 <= s.length, p.length <= 3 * 104`
- `s` 和 `p` 仅包含小写字母

**题解一：哈希表**

思路：使用数组作为哈希表，先在s中统计前`pLen`长度的字符串和`p`是否是字母异位词，然后向右滑动，每次取`pLen`长度去和`p`比较

```C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int sLen = s.size(), pLen = p.size();

        if (sLen < pLen) {
            return vector<int>();
        }

        vector<int> ans;
        vector<int> sCount(26);
        vector<int> pCount(26);
        for (int i = 0; i < pLen; ++i) {
            ++sCount[s[i] - 'a'];
            ++pCount[p[i] - 'a'];
        }

        if (sCount == pCount) {
            ans.emplace_back(0);
        }

        for (int i = 0; i < sLen - pLen; ++i) {
            --sCount[s[i] - 'a'];
            ++sCount[s[i + pLen] - 'a'];

            if (sCount == pCount) {
                ans.emplace_back(i + 1);
            }
        }

        return ans;
    }
};

```

## 两个数组的交集

### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

**示例 2：**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
```

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`

**题解一：哈希表**

思路：将`nums1`中的元素都加入一张哈希set，遍历`nums2`，如果`nums2`中某个元素在哈希set中出现则该元素是交集元素，为了去重，将之加入另一个哈希set中

```C++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num : nums2) {
            // 发现nums2的元素 在nums_set里又出现过
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

**题解二：排序+双指针**

思路：首先对两个数组进行排序，然后使用两个指针遍历两个数组。如果两个指针指向元素相同则该元素是交集元素，如果和上一次加入答案中的元素不同，则将之加入答案。如果两个指针指向元素值不同，向右移动较小值的指针继续比较，直至其中一个指针超出边界。

```C++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        int length1 = nums1.size(), length2 = nums2.size();
        int index1 = 0, index2 = 0;
        vector<int> intersection;
        while (index1 < length1 && index2 < length2) {
            int num1 = nums1[index1], num2 = nums2[index2];
            if (num1 == num2) {
                // 保证加入元素的唯一性
                if (!intersection.size() || num1 != intersection.back()) {
                    intersection.push_back(num1);
                }
                index1++;
                index2++;
            } else if (num1 < num2) {
                index1++;
            } else {
                index2++;
            }
        }
        return intersection;
    }
};
```

### [350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**示例 2:**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`

**进阶：**

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 `nums1` 的大小比 `nums2` 小，哪种方法更优？
- 如果 `nums2` 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

**题解一：哈希表**

思路：本题是想求得两个数组中的公共元素，若元素A在`nums1`中出现2次，在`nums2`中出现3次，则取小值，答案中只出现A2次。利用哈希表统计`nums1`中的元素和其出现的次数，遍历`nums2`中的元素，只要哈希表中有该元素，则将其加入`ans`，并将频次减一，当频次减为0时，在哈希表中删掉该元素。

```C++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> s1;
        vector<int> ans;
        for (int i : nums1) s1[i]++;       
        for (auto i : nums2) {
            if (s1.count(i)) {
                ans.push_back(i);
                s1[i]--;
                if (s1[i] == 0) {
                    s1.erase(i);
                }
            }
        }
        return ans;
    }
};
```

**题解二：排序+双指针（进阶1）**

思路：思路和上一道题很像，同样的先排序两个数组，利用两个指针遍历数组，当两个指针指向元素相同时，直接将该元素加入ans中，无需和上一次加入的元素进行比较，然后两个指针分别向右移动；若两个指针指向元素值不同，则移动值较小的那个指针。

```C++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        int length1 = nums1.size(), length2 = nums2.size();
        vector<int> intersection;
        int index1 = 0, index2 = 0;
        while (index1 < length1 && index2 < length2) {
            if (nums1[index1] < nums2[index2]) {
                index1++;
            } else if (nums1[index1] > nums2[index2]) {
                index2++;
            } else {
                intersection.push_back(nums1[index1]);
                index1++;
                index2++;
            }
        }
        return intersection;
    }
};
```

**题解三：哈希计数（进阶2）**

将较小的数组哈希计数，随后在另一个数组中根据哈希来寻找。
时间复杂度：O(max(n, m))
空间复杂度：O(min(n, m))

**题解四：过归并外排将两个数组排序后再使用排序双指针查找（进阶3）**

对应进阶问题三，如果内存十分小，不足以将数组全部载入内存，那么必然也不能使用哈希这类费空间的算法，只能选用空间复杂度最小的算法，即解法二。

但是解法二中需要改造，一般说排序算法都是针对于内部排序，一旦涉及到跟磁盘打交道（外部排序），则需要特殊的考虑。归并排序是天然适合外部排序的算法，可以将分割后的子数组写到单个文件中，归并时将小文件合并为更大的文件。当两个数组均排序完成生成两个大文件后，即可使用双指针遍历两个文件，如此可以使空间复杂度最低。

## [202. 快乐数](https://leetcode.cn/problems/happy-number/)

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。

- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

```
输入：n = 19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```

**示例 2：**

```
输入：n = 2
输出：false
```

**提示：**

- `1 <= n <= 2^31 - 1`

**题解一：快慢指针**

思路：使用 “快慢指针” 思想，找出循环：“快指针” 每次走两步，“慢指针” 每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为 1 引起的循环，是的话就是快乐数，否则不是快乐数。
注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是 int 型而投机取巧。

```C++
class Solution {
public:
    bool isHappy(int n) {
        int f = n, s = n;
        if (n == 0) return false;
        while (true) {
            f = nextNumber(nextNumber(f));
            s = nextNumber(s);
            if (s == 1) return true;
            if (f == s) return false;
        }
    }
private:
    int nextNumber(int n) {
        int sum = 0;
        while (n != 0) {
            sum += (n % 10) * (n % 10);
            n = n / 10;
        }
        return sum;
    }
};
```

**题解二：用哈希集合检测循环**

思路：在不断递归的过程中，会有以下三种可能

1. 最终会得到 1。
2. 最终会进入循环。
3. 值会越来越大，最后接近无穷大。

| Digits |    Largest    | Next |
| ------ | :-----------: | ---: |
| 1      |       9       |   81 |
| 2      |      99       |  162 |
| 3      |      999      |  243 |
| 4      |     9999      |  324 |
| 13     | 9999999999999 | 1053 |

由上表可知，对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除第三种选择。

算法分为两部分

第 1 部分我们按照题目的要求做数位分离，求平方和。

第 2 部分可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。

如果它不在哈希集合中，我们应该添加它。
如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 `false`。

```C++
class Solution {
public:
    bool isHappy(int n) {       
        unordered_set<int> count;
        long long sum = 0;
        while (true) {
            int sum = 0;
            while (n) {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            if (sum == 1) return true;
            if (count.count(sum)) {
                return false;
            } else {
                count.insert(sum);
            }
            n = sum;
        }    
    }
};
```

## [1. 两数之和](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

**进阶：**你可以想出一个时间复杂度小于 `O(n^2)` 的算法吗？

**题解一：哈希表**

思路：遍历数组，对当前遍历到的元素`num`求出与之和为`target`的另一个元素`need`，如果`need`已经出现在哈希表中，则直接输出结果，否则将`num`加入哈希表，继续遍历数组。注意：哈希表中的元素是`num`和其索引值。

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); ++i) {
            int need = target - nums[i];
            if (map.count(need) > 0) {
                return {map[need], i};
            } else {
                map[nums[i]] = i;
            }
        }
        return {-1, -1};
    }
};
```

## [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

**示例 1：**

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

**示例 2：**

```
输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```

 **提示：**

- `n == nums1.length`
- `n == nums2.length`
- `n == nums3.length`
- `n == nums4.length`
- `1 <= n <= 200`
- `-2^28 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 2^28`

**题解一：分组+哈希**

思路：将四个数组分成两部分，A 和 B 为一组，C 和 D 为另外一组。

对于 A 和 B，我们使用二重循环对它们进行遍历，得到所有 `A[i]+B[j]` 的值并存入哈希映射中。对于哈希映射中的每个键值对，每个键表示一种 `A[i]+B[j]`，对应的值为 `A[i]+B[j]` 出现的次数。

对于 C 和 D，我们同样使用二重循环对它们进行遍历。当遍历到 `C[k]+D[l]` 时，如果 `-(C[k]+D[l])` 出现在哈希映射中，那么将`-(C[k]+D[l])` 对应的值累加进答案中。

最终即可得到满足 `A[i]+B[j]+C[k]+D[l]=0`的四元组数目。

```C++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int, int> m12;
        int n = nums1.size();
        int ans = 0;
        for (int i : nums1) {
            for (int j : nums2) {
                m12[i + j]++;
            }
        }
        for (int i : nums3) {
            for (int j : nums4) {
                if (m12.count(-i - j)) {
                    ans += m12[-i - j];
                }
            }
        }
        return ans;
    }
};
```

## [15. 三数之和](https://leetcode.cn/problems/3sum/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]`满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

**提示：**

- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

**题解一：排序+双指针**

思路：对数组进行排序，遍历数组，遍历到`i`时，对`[i+1, n-1]`区间上利用双指针法寻找是否存在解，注意去重与减枝

1. 特判，对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回`[]` [][]。
2. 对数组进行排序。
3. 遍历排序后数组：
   - 若 `nums[i]>0`：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。
   - 对于重复元素：跳过，避免出现重复解
   - 令左指针 `L=i+1`，右指针 `R=n-1`，当 `L<R`时，执行循环：
     - 当 `nums[i]+nums[L]+nums[R]==0`，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R移到下一位置，寻找新的解
     - 若和大于 0，说明 nums[R] 太大，R左移
     - 若和小于 0，说明 nums[L] 太小，L右移

```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        int n = nums.size();
        if (n < 3) return ans;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n - 2; ++i) { 
            if (nums[i] > 0) return ans;
            //去重
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int l = i + 1, r = n - 1;
            while (l < r) {
                int sum = nums[i] + nums[l] + nums[r];
                if (sum == 0) {
                    ans.push_back({nums[i], nums[l], nums[r]});
                    l++;
                    r--;
                    //去重
                    while (l < r && nums[l] == nums[l - 1] && nums[r] == nums[r + 1]) {
                        l++;
                        r--;
                    } 
                } else if (sum > 0) {
                    r--;
                } else {
                    l++;
                }
            }
        }
        return ans;
    }
};
```

## [18. 四数之和](https://leetcode.cn/problems/4sum/)

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]`（若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

**提示：**

- `1 <= nums.length <= 200`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`

**题解一：排序+双指针**

思路：思路和三数之和一样，区别是前两个for循环确定前两个数，双指针确定后两个数

注意去重和剪枝，剪枝时`continue`和`break`的情况要注意

```C++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> ans;
        int n = nums.size();
        if (n < 4) return ans;
        sort(nums.begin(), nums.end());
        //减枝
        if ((long) nums[0] + nums[1] + nums[2] + nums[3] > target || 
            (long) nums[n - 1] + nums[n - 2] + nums[n - 3] + nums[n - 4] < target) {
            return ans;
        }
        for (int i = 0; i < n - 3; ++i) {
            //去重
            if (i > 0 && nums[i] == nums[i-1]) {
                continue;
            }
            //剪枝
            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
                break;
            }
            if ((long) nums[i] + nums[n - 1] + nums[n - 2] + nums[n - 3] < target) {
                continue;
            }
            for (int j = i + 1; j < n - 2; ++j) {
                //去重
                if (j > i + 1 && nums[j] == nums[j - 1]) continue; 
                //剪枝
                if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {
                    break;
                }
                if ((long) nums[i] + nums[j] + nums[n - 1] + nums[n - 2] < target) {
                    continue;
                }
                int l = j + 1, r = n - 1;
                while (l < r) {
                    int sum = nums[i] + nums[j] + nums[l] + nums[r];
                    if (sum == target) {
                        ans.push_back({nums[i], nums[j], nums[l], nums[r]});
                        l++;
                        r--;
                        while (l < r && nums[l] == nums[l - 1] && nums[r] == nums[r + 1]) {
                            l++;
                            r--;
                        }
                    } else if (sum > target) {
                        r--;
                    } else {
                        l++;
                    }
                }
            }
        }
        return ans;
    }
};
```

# 字符串

## [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

**示例 1：**

```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

**示例 2：**

```
输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

**提示：**

- `1 <= s.length <= 105`
- `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符

**题解一：swap原地交换**

```C++
class Solution {
public:
    void reverseString(vector<char>& s) {
        for (int i = 0, j = s.size() - 1; i < j; i++, j--) {
            swap(s[i],s[j]);
        }
    }
};
```

## [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例 2：**

```
输入：s = "abcd", k = 2
输出："bacd"
```

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由小写英文组成
- `1 <= k <= 104`

思路：遍历字符串，只要从当前位置起有k个字符，则翻转这k个，若不足k个，则翻转剩余所有，更新当前位置。

```C++
class Solution {
public:
    string reverseStr(string s, int k) {
        int n = s.size();
        for (int i = 0; i < n; i += (2 * k)) {
            // 1. 每隔 2k 个字符的前 k 个字符进行反转
            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
            if (i + k <= n) {
                reverse(s.begin() + i, s.begin() + i + k );
                continue;
            }
            // 3. 剩余字符少于 k 个，则将剩余字符全部反转。
            reverse(s.begin() + i, s.begin() + n);
        }
        return s;
    }
};
```

## [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

**示例 1：**

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

**限制：**

```
0 <= s 的长度 <= 10000
```

**题解一：双指针**

思路：首先根据字符串中空格的数量对字符串进行扩容，然后从字符串的末尾开始填字符。

两个指针`right`指向扩容后字符串的末尾，另一个指针`left`指向原字符串的末尾，如果`left`所指向内容不为空格，则`s[right] = s[left]`，两个指针均向左移；若`left`所指向内容为空格，则`right`指针从右向左依次赋值`02%`

```C++
class Solution {
public:
    string replaceSpace(string s) {
        int n1 = s.size();
        int count = 0;
        for (char ch : s) {
            if (ch == ' ') count++;
        }
        int n2 = n1 + count * 2;
        s.resize(n2);

        for (int l = n1 - 1, r = n2 - 1; l >= 0; ) {
            if (s[l] != ' ') {
                s[r--] = s[l--];
            } else {
                l--;
                s[r--] = '0';
                s[r--] = '2';
                s[r--] = '%';
            }
        }
        return s;
    }
};
```

## [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**示例 2：**

```
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
```

**示例 3：**

```
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```

**提示：**

- `1 <= s.length <= 10^4`
- `s` 包含英文大小写字母、数字和空格 `' '`
- `s` 中 **至少存在一个** 单词

**进阶：**如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 `O(1)` 额外空间复杂度的 **原地** 解法。

**题解一：原地修改**

思路：首先对字符串做一次翻转，然后对字符串中的每个单词做翻转同时将单词之间的空格变成一个

利用两个指针`start`和`end`来确定每一个单词的范围，再将单词移至`idx`索引处，除了`idx`为0时不用添加空格外，后面添加新单词时都需要添加一个空格

![fig](https://pic.leetcode-cn.com/Figures/151/mutable2.png)

```C++
//时间复杂度O(n), 空间复杂度O(1)
class Solution {
public:
    string reverseWords(string s) {
        // 反转整个字符串
        reverse(s.begin(), s.end());

        int n = s.size();
        int idx = 0;
        for (int start = 0; start < n; ++start) {
            if (s[start] != ' ') {
                // 填一个空白字符然后将idx移动到下一个单词的开头位置
                if (idx != 0) s[idx++] = ' ';

                // 循环遍历至单词的末尾
                int end = start;
                while (end < n && s[end] != ' ') s[idx++] = s[end++];

                // 反转整个单词
                reverse(s.begin() + idx - (end - start), s.begin() + idx);

                // 更新start，去找下一个单词
                start = end;
            }
        }
        s.erase(s.begin() + idx, s.end());
        return s;
    }
};

```

**题解二：双端队列**

思路：由于双端队列支持从队列头部插入的方法，因此我们可以沿着字符串一个一个单词处理，然后将单词压入队列的头部，再将队列转成字符串即可。

![fig](https://pic.leetcode-cn.com/Figures/151/deque2.png)

```C++
//时间复杂度O(n), 空间复杂度O(n)
class Solution {
public:
    string reverseWords(string s) {
        int left = 0, right = s.size() - 1;
        // 去掉字符串开头的空白字符
        while (left <= right && s[left] == ' ') ++left;

        // 去掉字符串末尾的空白字符
        while (left <= right && s[right] == ' ') --right;

        deque<string> d;
        string word;

        while (left <= right) {
            char c = s[left];
            if (word.size() && c == ' ') {
                // 将单词 push 到队列的头部
                d.push_front(move(word));
                word = "";
            }
            else if (c != ' ') {
                word += c;
            }
            ++left;
        }
        d.push_front(move(word));
        
        string ans;
        while (!d.empty()) {
            ans += d.front();
            d.pop_front();
            if (!d.empty()) ans += ' ';
        }
        return ans;
    }
};
```

**题解三：双指针法**

思路：两个指针从字符串末尾截取单词，并倒序的加入`ans`

```C++
//时间复杂度O(n),空间复杂度O(n)
class Solution {
public:
    string reverseWords(string s) {
        string ans;
        int n = s.size();
        int r = n - 1;
        int b, e;
        while (r >= 0) {
            while (r >= 0 && s[r] == ' ')  {
                r--;
            }
            if (r < 0) break;
            e = r;
            while (r >= 0 && s[r] != ' ') {
                r--; 
            }
            b = r + 1;
            for (int i = b; i <= e; i++) {
                ans.push_back(s[i]);
            }
            ans.push_back(' ');
        }
        if (ans.back() == ' ') {
            ans.erase(ans.size() - 1);
        }
        return ans;
    }
};
```

## [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

**示例 1：**

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```

**示例 2：**

```
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```

**限制：**

- `1 <= k < s.length <= 10000`

**题解一：分组+旋转**

思路：先旋转前k个，再旋转后面的部分，最后整体旋转

```C++
//时间复杂度O(n), 空间复杂度O(1)
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(), s.begin() + n);
        reverse(s.begin() + n, s.end());
        reverse(s.begin(), s.end());
        return s;
    }
};
```

**题解二：双指针**

思路：先复制前k个字符到字符串的末尾，然后利用双指针法将[k+1, n-1]范围内的字符覆盖到字符串的开头，最后截断末尾的k个字符

```C++
//时间复杂度O(n), 空间复杂度O()
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        for (int i = 0; i < n; i++) {
            s.push_back(s[i]);
        }
        for (int i = n, j = 0; i < s.size(); i++) {
            s[j++] = s[i];
        }
        s.erase(s.size() - n);
        return s;
    }
};

```

## [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

**示例 2：**

```
输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
```

**提示：**

- `1 <= haystack.length, needle.length <= 10^4`
- `haystack` 和 `needle` **仅由小写英文字符组成**

**题解一：KMP算法**

```C++
//时间复杂度O(), 空间复杂度O()
class Solution {
public:
    int strStr(string haystack, string needle) { 
        if (needle.size() == 0) return 0;
        int next[needle.size()];
        getNext(next, needle); 
        int i1 = 0;
        int i2 = 0;
        while (i1 < haystack.size() && i2 < needle.size()) {
            if (haystack[i1] == needle[i2]) {
                i1++;
                i2++;
            } else if (i2 > 0) {
                i2 = next[i2 - 1];
            } else {
                i1++;
            }
        }
        return i2 == needle.size() ? i1 - i2 : -1;       
    }
private:
    void getNext(int* next, string s) {
        next[0] = 0;
        int i = 1;
        int j = 0;
        while (i < s.size()) {
            if (s[i] == s[j]) {
                next[i++] = ++j;
            } else if (j > 0) {
                j = next[j - 1];
            } else {
                next[i++] = 0;
            }
        }
    }
};
```

## [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

**示例 1:**

```
输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
```

**示例 2:**

```
输入: s = "aba"
输出: false
```

**示例 3:**

```
输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
```

**提示：**

- `1 <= s.length <= 10^4`
- `s` 由小写英文字母组成

**题解一：拼接查找法**

思路：假设字符串`s`是由某个子串重复多次构成，其子串为`x`，有`s = xx`，将两个s拼接在一块就是`xxxx`，可以看到在`ss`这个字符串中查找`s`，其出现的位置除了`0`和`s.size()`外必然还有一处，是第一个`s`中的第二个`x`和第二个`s`中的第一个`x`构成的`s`，可以利用是否存在这第三个`s`来判断。

```C++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        return (s + s).find(s, 1) != s.size();
    }
};
```

**题解二：KMP**

思路：也可以利用KMP算法中的`next`数组的特性来判断，对于满足题意的字符串`s`，其`next`数组的值必然是前面有`n1`个0，后面有`n2`个数分别是1，2，3，...，n2，且满足`n2 % n1 == 0`。例如字符串abababab，其`next`数组的值是[0, 0, 1, 2, 3, 4, 5, 6]

```C++
//时间复杂度O(n), 空间复杂度O(n)
class Solution {
public:
    void getNext(int* next, string s) {
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.size(); i++) {
            while (j > 0 && s[j] != s[i]) {
                j = next[j - 1];
            }
            if (s[j] == s[i]) {
                j++;
                next[i] = j;
            } else {
                next[i] = j;
            }
        }
    }
    bool repeatedSubstringPattern(string s) {
        int n = s.size(), n1;;
        int next[n];
        getNext(next, s);
        if (n < 2) return false;
        if (next[n - 1] == 0) return false;
        n1 = n - next[n - 1];
        return n % n1 == 0;
    }
};
```

# 双指针

## 移除元素

### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

同数组---移除元素---27. 移除元素

### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

同数组---移除元素---26. 删除有序数组中的重复项

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

同数组---移除元素---283. 移动零

### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

同数组---移除元素---844. 比较含退格的字符串

### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

同数组---977. 有序数组的平方

## [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

同字符串---344. 反转字符串

## [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

同字符串---剑指 Offer 05. 替换空格

## [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

同字符串---151. 反转字符串中的单词

## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

同链表---206. 反转链表

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

同链表---19. 删除链表的倒数第 N 个结点

## [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

同链表---160. 相交链表

## [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

同链表---142. 环形链表 II
