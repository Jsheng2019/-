- [01.malloc和new的区别](#01malloc和new的区别)
- [02.malloc的底层实现](#02malloc的底层实现)
- [03.C++头文件“<>”和“ “” ”的区别](#03c头文件和--的区别)
- [04.堆和栈的区别](#04堆和栈的区别)
- [05.内存泄漏](#05内存泄漏)
- [06.常用设计模式（需要补充）](#06常用设计模式需要补充)
- [07.指针和引用的区别](#07指针和引用的区别)
- [08.static关键字](#08static关键字)
# 01.malloc和new的区别

1. **申请的内存所在位置**

   new操作符是从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请的，该内存就是自由存储区，自由存储区可以是堆，也可以是静态存储区，这要看operator new在哪里分配的，而堆是操作系统上的术语，是操作系统所维护的一块特殊内存

2. **返回类型安全性**

   new操作符内存分配成功时，返回的是对象类型的指针，类型严格于对象匹配，无须进行类型转换

   而malloc内存分配成功返回的是void*，需要通过类型强转为我们需要的类型

3. **内存分配失败时的返回值**

   new内存分配失败时会抛出异常（bad_alloc），malloc分配内存失败时返回NULL

4. **是否需要指定内存大小**

   使用new操作符申请内存分配时无需指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显示指出所需内存的大小

5. **是否调用构造函数/析构函数**

   使用new操作符来分配对象内存时会经历三个步骤

   第一步：调用operator new函数（对于数组是operator new[]）分配一块足够大的，未使用的内存空间以便于存储特定类型的对象
   第二步：编译器运行相应的构造函数以构造对象，并为其传入初值
   第三步：对象构造完成后，返回一个指向该对象的指针
   使用delete操作符来释放对象内存时会经历两个步骤

   第一步：调用对象的析构函数
   第二步：编译器调用operator delete（或operator delete[]）函数释放内存空间

   而malloc不会调用对象的构造函数或是析构函数

6. **对数组的处理**

   C++提供了new[]和delete[]来专门处理数组类型，new[]会分别调用构造函数初始化每一个数组元素，释放对象时调用析构函数，注意new[]和delete[]需要配套使用，否则会造成内存泄漏

   malloc并不需要知道这块内存上面存了什么，如要我们要分配一个数组的内存，需要我们手动自定数组的大小

7. **new于malloc是否可以互相调用**

   new底层调用的时malloc，而malloc的实现不能去调用new

8. **是否可以被重载**

   operator new / opertor delete可以被重载

   malloc / free并不允许重载

9. **能够直观地重新分配内存**

   使用malloc分配内存后，如果使用地过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存地扩充

   new没有这样方法来扩充内存

   **总结一下**

   malloc就好像是给你一块内存，你拿它去随便做什么

   new不仅给你一块内存，还帮你把这块内存划分好（new[]）并初始化（构造函数） 

# [02.malloc的底层实现](https://xiaolincoding.com/os/3_memory/malloc.html#free-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98-%E4%BC%9A%E5%BD%92%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97)

malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。

malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。

- 方式一：通过 brk() 系统调用从堆分配内存
- 方式二：通过 mmap() 系统调用在文件映射区域分配内存；

方式一实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。如下图：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/brk%E7%94%B3%E8%AF%B7.png)

方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。如下图：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/mmap%E7%94%B3%E8%AF%B7.png)

**什么场景下 malloc() 会通过 brk() 分配内存？又是什么场景下通过 mmap() 分配内存？**

malloc() 源码里默认定义了一个阈值：

- 如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
- 如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；

注意，不同的 glibc 版本定义的阈值也是不同的。

**malloc() 分配的是物理内存吗？**

不是的，malloc() 分配的是*虚拟内存*。

如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。

只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。

**malloc(1) 会分配多大的虚拟内存？**

malloc() 在分配内存的时候，并不是老老实实按用户预期申请的字节数来分配内存空间大小，而是会预分配更大的空间作为内存池。

具体会预分配多大的空间，跟 malloc 使用的内存管理器有关系，我们就以 malloc 默认的内存管理器（Ptmalloc2）来分析。

malloc(1) 实际上预分配 132K 字节的内存。

**malloc 申请的内存，free 释放内存会归还给操作系统吗？**

- malloc 通过 **brk()** 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用；
- malloc 通过 **mmap()** 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。

**为什么不全部使用 mmap 来分配内存？**

频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。

为了改进这两个问题，malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。

等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗。

**为什么不全部使用 brk 来分配？**

前面我们提到通过 brk 从堆空间分配的内存，并不会归还给操作系统，那么我们那考虑这样一个场景。

如果我们连续申请了 10k，20k，30k 这三片内存，如果 10k 和 20k 这两片释放了，变为了空闲内存空间，如果下次申请的内存小于 30k，那么就可以重用这个空闲内存空间。

但是如果下次申请的内存大于 30k，没有可用的空闲内存空间，必须向 OS 申请，实际使用内存继续增大。

因此，随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多不可用的碎片，导致“内存泄露”。而这种“泄露”现象使用 valgrind 是无法检测出来的。

所以，malloc 实现中，充分考虑了 brk 和 mmap 行为上的差异及优缺点，默认分配大块内存 (128KB) 才使用 mmap 分配内存空间。

# 03.C++头文件“<>”和“ “” ”的区别

<>和"“表示编译器在搜索头文件时的顺序不同

<>表示从系统目录下开始搜索，然后再搜索PATH环境变量所列出的目录，不搜索当前目录

”“是表示从当前目录开始搜索，然后是系统目录和PATH环境变量所列出的目录。

所以，系统头文件一般用<>，用户自己定义的则可以使用”"，加快搜索速度。

# 04.堆和栈的区别

- 申请方式不同。
  - 栈由系统自动分配。
  - 堆是自己申请和释放的。

- 申请大小限制不同。
  - 栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。
  - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。
- 申请效率不同。
  - 栈由系统分配，速度快，不会有碎片。
  - 堆由程序员分配，速度慢，且会有碎片。
- 存储内容不同
  - 栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。
  - 而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排;
- 底层不同
  - 栈是连续的空间
  - 堆是不连续的空间

| 堆               | 栈                                                           |                                                              |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **管理方式**     | 堆中资源由程序员控制（容易产生memory leak）                  | 栈资源由编译器自动管理，无需手工控制                         |
| **内存管理机制** | 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） | 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） |
| **空间大小**     | 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大 | 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置） |
| **碎片问题**     | 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低       | 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别） |
| **生长方向**     | 堆向上，向高地址方向增长。                                   | 栈向下，向低地址方向增长。                                   |
| **分配方式**     | 堆都是动态分配（没有静态分配的堆）                           | 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 |
| **分配效率**     | 堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。    | 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。 |

# 05.内存泄漏

**1) 内存泄漏**

内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制；

**2) 后果**

只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种证照：性能下降到内存逐渐用完，导致另一个程序失败；

**3）解决方法**

智能指针、RAII机制

RAII，即Resource Acquisition Is Initialization，在初始化中获取资源。

RAII机制，通过在栈上创建临时变量，这样临时变量就接管了堆上内存的控制权，当该临时变量声明周期结束时，则对应的堆上内存自然就被释放了。

# 06.常用设计模式（需要补充）

**1.单例模式**

一个类只有一个实例，且该类能自行创建这个实例的一种模式，单例类对外提供一个访问该单例的全局访问点

优点：单例模式可以保证内存里只有一个实例，减少了内存的开销。
        	可以避免对资源的多重占用。
        	单例模式设置全局访问点，可以优化和共享资源的访问。

缺点：单例模式一般没有接口，扩展困难。
       	单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则

***饿汉式单例***：类一旦加载就创建一个单例，保证在调用getInstance方法之前单例已经存在，这种饿汉式单例会造成空间浪费。

***懒汉式单例***：为了避免内存空间浪费，采用懒汉式单例，即用到该单例对象的时候再创建。

**2、工厂方法模式**

实例化对象不是用new，用工厂方法替代。

将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

***简单工厂模式***：用来生产同一等级架构中的任意产品(对于增加新的产品，需要修改已有代码)

***工厂方法模式***：用来生产同一等级架构中的固定产品，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。(支持增加任意产品)

简单工厂模式与工厂方法模式比较：

*结构的复杂度*：简单工厂模式占优。
*代码的复杂度*：简单工厂模式占优。
*编程的复杂度*：简单工厂模式占优。
*管理的复杂的*：简单工厂模式占优。
因此，虽然简单工厂模式不符合设计模式，但是实际使用远大于工厂方法模式。

**3、代理模式**

由于某些原因需要给某对象提供一个代理以控制对该对象的访问。

这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

***静态代理模式：***

角色分析：

1、抽象角色：一般会使用接口或抽象类来解决

2、真实角色：被代理的角色

3、代理角色：代理真实角色，代理真实角色后我们会进行一些附属操作

4、访问角色：访问代理对象的人

代理模式优点：可以使真实角色的操作更加纯粹!不用去关注一些公共的业务，公共也就可以交给代理角色，实现了业务的分工，公共业务发生扩展的时候，方便集中管理!
代理模式缺点：一个真实角色就会产生一个代理角色;代码量会翻倍开发效率会变低，也许，这样无法理解到代理模式的好处。举个例子也许能更好理解，比如说我们想要在原有固定功能上新增业务，按照开闭原则我们是不能对原有代码进行修改的。但是我们可以通过代理模式，增加代理，在实现原有功能的情况下写入新的功能，创建对象时也就可以使用代理，完成操作。

***动态代理模式（不全）***

虽然静态代理模式可以很好的解决开闭原则，但是每有一个真实角色就会产生一个代理，代码量翻倍过于臃肿，开发效率较低。

# [07.指针和引用的区别](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_3%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB)

- 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
- 指针可以有多级，引用只有一级
- 指针可以为空，引用不能为NULL且在定义时必须初始化
- 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
- sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。
- 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

# 08.static关键字

> **c/c++共有**

- 修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。
- 修饰局部变量时，表明该变量的值不会因为函数终止而丢失。
- 修饰函数时，表明该函数只在同一文件中调用。

> **c++独有**：

- 修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归 所有对象共有。
- 用static修饰不访问非静态数据成员的类成员函数。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量

